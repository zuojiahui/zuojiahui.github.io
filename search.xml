<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/2021/11011111.html"/>
      <url>/2021/11011111.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序入坑</title>
      <link href="/2021/10135140.html"/>
      <url>/2021/10135140.html</url>
      
        <content type="html"><![CDATA[<h2 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h2><p>小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><h3 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h3><p>小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。<br><code>普通网页开发</code>:<br>​ 渲染线程和脚本线程是互斥的。<br>网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作<br>网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ 浏览器等，在移动端需要面对 Safari、Chrome 以及 iOS、Android 系统中的各式 WebView<br><code>小程序</code>:<br>渲染线程和脚本线程是分开的，分别运行在不同的线程中。<br>小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API，这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。<br>而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表所示。</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>iOS</td><td>JavaScriptCore</td><td>WKWebView</td></tr><tr><td>安卓</td><td>V8</td><td>chromium 定制内核</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><h3 id="小程序与普通网页开发文件对比"><a href="#小程序与普通网页开发文件对比" class="headerlink" title="小程序与普通网页开发文件对比"></a>小程序与普通网页开发文件对比</h3><table><thead><tr><th>结构</th><th>传统 Web</th><th>微信小程序</th></tr></thead><tbody><tr><td>结构</td><td>HTML</td><td>WXML</td></tr><tr><td>样式</td><td>CSS</td><td>WXCSS</td></tr><tr><td>逻辑</td><td>JavaScript</td><td>JavaScript</td></tr><tr><td>配置</td><td>无</td><td>JSON</td></tr></tbody></table><h3 id="基本项目目录结构"><a href="#基本项目目录结构" class="headerlink" title="基本项目目录结构"></a>基本项目目录结构</h3><div align="left"><img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/微信图片_20211007212116.png" width = 50% height = 80% /></div><h3 id="小程序配置文件"><a href="#小程序配置文件" class="headerlink" title="小程序配置文件"></a>小程序配置文件</h3><p>小程序应用程序会包括最基本的两种配置文件，一种是全局的 <code>app.json</code> 和 页面自已的 <code>page.json</code></p><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 <code>tab</code> 等。<br>以下是一个包含了部分常用配置选项的 app.json ：</p><pre><code>&#123;  &quot;pages&quot;: [    &quot;pages/index/index&quot;,    &quot;pages/logs/index&quot;  ],  &quot;window&quot;: &#123;    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;  &#125;,  &quot;tabBar&quot;: &#123;    &quot;list&quot;: [&#123;      &quot;pagePath&quot;: &quot;pages/index/index&quot;,      &quot;text&quot;: &quot;首页&quot;    &#125;, &#123;      &quot;pagePath&quot;: &quot;pages/logs/index&quot;,      &quot;text&quot;: &quot;日志&quot;    &#125;]  &#125;,  &quot;networkTimeout&quot;: &#123;    &quot;request&quot;: 10000,    &quot;downloadFile&quot;: 10000  &#125;,  &quot;debug&quot;: true&#125;</code></pre><p>完整配置项说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">小程序全局配置</a></p><h4 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h4><p>每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。</p><pre><code>&#123;  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,  &quot;backgroundTextStyle&quot;: &quot;light&quot;&#125;</code></pre><p>完整配置项说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html">小程序页面配置</a></p><h4 id="sitemap-配置"><a href="#sitemap-配置" class="headerlink" title="sitemap 配置"></a>sitemap 配置</h4><p>小程序根目录下的 <code>sitemap.json</code> 文件用于配置小程序及其页面是否被微信索引<br>完整配置项说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html">sitemap 配置</a></p><h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><p>组件使用说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/">组件文档</a></p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>.js 文件</p><pre><code>Page(&#123;  data: &#123;    msg: &quot;Hello !!!&quot;,    num: 100,    show: true,    parson: &#123;      name: &quot;鸣人&quot;,      age: 18    &#125;  &#125;,&#125;)</code></pre><p>.wxml 文件</p><pre><code>&lt;view&gt;  &lt;!-- 字符串类型 --&gt;  &lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt;  &lt;!-- 数字类型 --&gt;  &lt;view&gt;&#123;&#123;num&#125;&#125;&lt;/view&gt;  &lt;!-- 布尔类型 --&gt;  &lt;checkbox checked=&quot;&#123;&#123;show&#125;&#125;&quot;&gt;是否展示&lt;/checkbox&gt;  &lt;!-- 对象类型 --&gt;  &lt;view&gt;名字 : &#123;&#123;parson.name&#125;&#125; 年龄 : &#123;&#123;parson.age&#125;&#125;&lt;/view&gt;&lt;/view&gt;</code></pre><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><pre><code>&lt;view&gt;  &lt;!-- 数字加减 --&gt;  &lt;view&gt;&#123;&#123;1 + 1&#125;&#125;&lt;/view&gt;  &lt;!-- 字符串拼接 --&gt;  &lt;view&gt;&#123;&#123;"1" + "1"&#125;&#125;&lt;/view&gt;  &lt;!-- 三元表达式 --&gt;  &lt;view&gt;&#123;&#123;10 % 2 === 0 ? "偶数" : "奇数"&#125;&#125;&lt;/view&gt;&lt;/view&gt;</code></pre><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>.js 文件</p><pre><code>Page(&#123;  data: &#123;    dataList: [&#123;        id: 1,        name: &quot;鸣人&quot;      &#125;,      &#123;        id: 2,        name: &quot;佐助&quot;      &#125;,      &#123;        id: 2,        name: &quot;雏田&quot;      &#125;,      &#123;        id: 2,        name: &quot;小樱&quot;      &#125;,    ],    parson: &#123;      name: &quot;鸣人&quot;,      age: 18    &#125;  &#125;,&#125;)</code></pre><p>.wxml 文件</p><pre><code>&lt;view&gt;  &lt;!-- wx:for=&quot;&#123;&#123;数组或者对象&#125;&#125;&quot; wx:for-item=&quot;循环项的名称&quot; wx:for-index=&quot;循环项的索引&quot; wx:key=&quot;唯一值，用于提高列表渲染性能&quot; --&gt;  &lt;!-- 如果数组为普通数组 列如：[1,2,3,4]   wx:key=&quot;*this&quot;  *this 表示循环项--&gt;  &lt;!--  默认情况下:  可以不写 wx:for-item=&quot;item&quot;  wx:for-index=&quot;index&quot;，小程序会默认添加(只有一层循环下可以省略)  当出现 数组的嵌套循环的时候 以下绑定 不能重名  wx:for-item=&quot;item&quot;  wx:for-index=&quot;index&quot;  --&gt;  &lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot; wx:key=&quot;id&quot;&gt;    索引 ：&#123;&#123;index&#125;&#125;    值 ： &#123;&#123;item.name&#125;&#125;  &lt;/view&gt;  &lt;view wx:for=&quot;&#123;&#123;parson&#125;&#125;&quot; wx:for-item=&quot;value&quot; wx:for-index=&quot;key&quot; wx:key=&quot;id&quot;&gt;    属性：&#123;&#123;key&#125;&#125;    值：&#123;&#123;value&#125;&#125;  &lt;/view&gt;&lt;/view&gt;</code></pre><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><pre><code>&lt;!--  场景使用：   wx:if ：当标签不是频繁切换的时候优先使用 （直接把标签从页面移除）   hidden ：当标签频繁切换的时候优先使用 （通过使用样式的方式来切换显示）   注意 ：(hidden 属性不可和样式 display 一起使用，否则 hidden 属性会失效)--&gt;&lt;view&gt;  &lt;!-- wx:if=&quot;&#123;&#123;true/false&#125;&#125;&quot; --&gt;  &lt;view wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt; 显示 &lt;/view&gt;  &lt;view wx:if=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; 隐藏 &lt;/view&gt;  &lt;!-- wx:if  wx:elif wx:else--&gt;  &lt;view wx:if=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; 1 &lt;/view&gt;  &lt;view wx:elif=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; 2 &lt;/view&gt;  &lt;view wx:else&gt; 3 &lt;/view&gt;  &lt;!-- hidden 默认为 true--&gt;  &lt;view hidden=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;hidden1&lt;/view&gt;  &lt;view hidden&gt;hidden2&lt;/view&gt;&lt;/view&gt;</code></pre><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>.js 文件</p><pre><code>Page(&#123;  data: &#123;    num: 0  &#125;,  // 输入框事件  handInput(e) &#123;    this.setData(&#123;      num: Number(e.detail.value)    &#125;)  &#125;,  //加 减 事件  handbindtap(value) &#123;    const num = value.currentTarget.dataset.num    this.setData(&#123;      num: this.data.num + num    &#125;)  &#125;&#125;)</code></pre><p>.wxml 文件</p><pre><code>&lt;view&gt;  &lt;input type=&quot;text&quot; bindinput=&quot;handInput&quot; /&gt;  &lt;button bindtap=&quot;handbindtap&quot; data-num=&quot;&#123;&#123;1&#125;&#125;&quot;&gt;+&lt;/button&gt;  &lt;button bindtap=&quot;handbindtap&quot; data-num=&quot;&#123;&#123;-1&#125;&#125;&quot;&gt;-&lt;/button&gt;  &lt;view&gt;&#123;&#123;num&#125;&#125;&lt;/view&gt;&lt;/view&gt;</code></pre><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>详情使用说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/">自定义组件文档</a></p><h3 id="创建自定义组件"><a href="#创建自定义组件" class="headerlink" title="创建自定义组件"></a>创建自定义组件</h3><p>类似于页面，一个自定义组件由 json wxml wxss js 4 个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可将这一组文件设为自定义组件）</p><pre><code>&#123;  &quot;component&quot;: true&#125;</code></pre><p>同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">组件模板和样式</a></p><pre><code>&lt;!-- 这是自定义组件的内部WXML结构 --&gt;&lt;view class=&quot;inner&quot;&gt;  &#123;&#123;innerText&#125;&#125;&lt;/view&gt;&lt;slot&gt;&lt;/slot&gt;</code></pre><pre><code>/* 这里的样式只应用于这个自定义组件 */.inner &#123;  color: red;&#125;</code></pre><p>在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。</p><pre><code>Component(&#123;  properties: &#123;    // 这里定义了innerText属性，属性值可以在组件使用时指定，由父级传递过来    innerText: &#123;      type: String,      value: &#39;default value&#39;,    //默认值    &#125;  &#125;,  data: &#123;    // 这里是一些组件内部数据    someData: &#123;&#125;  &#125;,  methods: &#123;    // 这里是一个自定义组件自已的方法    customMethod: function()&#123;&#125;  &#125;&#125;)</code></pre><p>使用自定义组件: 使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径</p><pre><code>&#123;  &quot;usingComponents&quot;: &#123;    &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot;  &#125;&#125;</code></pre><h3 id="Component-构造器"><a href="#Component-构造器" class="headerlink" title="Component 构造器"></a>Component 构造器</h3><p>Component 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。<br>详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html">Component 参考文档</a></p><pre><code>Component(&#123;  behaviors: [],  properties: &#123;    myProperty: &#123; // 属性名      type: String,      value: &#39;&#39;    &#125;,    myProperty2: String // 简化的定义方式  &#125;,    data: &#123;&#125;, // 私有数据，可用于模板渲染  lifetimes: &#123;    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名    attached: function () &#123; &#125;,    moved: function () &#123; &#125;,    detached: function () &#123; &#125;,  &#125;,  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名  attached: function () &#123; &#125;, // 此处attached的声明会被lifetimes字段中的声明覆盖  ready: function() &#123; &#125;,  pageLifetimes: &#123;    // 组件所在页面的生命周期函数    show: function () &#123; &#125;,    hide: function () &#123; &#125;,    resize: function () &#123; &#125;,  &#125;,  methods: &#123;    onMyButtonTap: function()&#123;      this.setData(&#123;        // 更新属性和数据的方法与更新页面数据的方法类似      &#125;)    &#125;,    // 内部方法建议以下划线开头    _myPrivateMethod: function()&#123;      // 这里将 data.A[0].B 设为 &#39;myPrivateData&#39;      this.setData(&#123;        &#39;A[0].B&#39;: &#39;myPrivateData&#39;      &#125;)    &#125;,    _propertyChange: function(newVal, oldVal) &#123;    &#125;  &#125;&#125;)</code></pre><h3 id="组件间通信与事件"><a href="#组件间通信与事件" class="headerlink" title="组件间通信与事件"></a>组件间通信与事件</h3><p>组件间的基本通信方式有以下几种  </p><ul><li>WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。</li><li>事件：用于子组件向父组件传递数据，可以传递任意数据。</li><li>如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法</li></ul><h4 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h4>]]></content>
      
      
      <categories>
          
          <category> 小程序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript从入门到入坑</title>
      <link href="/2021/080217690.html"/>
      <url>/2021/080217690.html</url>
      
        <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在使用 npm 命令之前电脑必须安装 nodejs</p><pre><code>npm install -g typescript或者cpm install -g typescript或者yarn global add typescript验证是否安装成功tsc -v</code></pre><h3 id="TypeScript-中的数据类型"><a href="#TypeScript-中的数据类型" class="headerlink" title="TypeScript 中的数据类型"></a>TypeScript 中的数据类型</h3><pre><code>// 布尔类型  booleanconst show: boolean = true// 数字类型  numberconst num: number = 123.4// 字符串类型  stringconst str: string = &quot;你好!&quot;// 数组类型  array   ts中定义数组有两种方式// 1. 第一种定义数组方式const arr: number[] = [1, 2, 3, 4, 5, 6]const arr1: string[] = [&quot;js&quot;, &quot;css&quot;]// 2. 第一种定义数组方式 (泛型)const arr2: Array&lt;number&gt; = [1, 2, 3, 4, 5, 6]const arr3: Array&lt;string&gt; = [&quot;js&quot;, &quot;css&quot;]// 2. 第三种定义数组方式const arr4: any[] = [11, &quot;22&quot;, true]// 元组类型  tuple  (属于数组的一种)const arr5: [boolean, string, number] = [true, &quot;你好&quot;, 123]/*枚举类型 enumenum 枚举名 &#123;    标识符[=整型常数]    ...    标识符[=整型常数]&#125;pay_status   0 未支付  1 支付  2 交易成功flag 1 true  2 false*/enum Flag &#123; true = 1, false = 2 &#125;const f: Flag = Flag.trueconsole.log(f)  // 1enum Num &#123; num0, num1, num2 &#125;   // 为赋值即为索引值const n: Num = Num.num0console.log(n)  // 0// 任意类型 any    const anyType: any = trueconst anyType1: any = 123const anyType3: any = &quot;你好&quot;// null 和 undefined  其他(never类型) 数据类型的子类型let numUndefined: number | undefined;console.log(numUndefined)  // undefined// 一个元素可能是 number 可能是 null 可能是 undefinedlet anyTypes: number | null | undefined;// void 类型 ：表示没有任何类型，一般用于定义方法没有返回值/*es5的定义方法function run() &#123;    console.log(&quot;run&quot;)&#125;run()*/function run(): void &#123;    console.log(&quot;run&quot;)&#125;run()// 如果有返回值function run1(): number &#123;    return 123&#125;run()// never类型：其他类型（包括 null 和 undefined）的子类型，代表从来不会出现值// 声明的 never 的变量只能被 never类型赋值let a: never = (() =&gt; &#123;    throw new Error(&quot;错误&quot;)&#125;)()</code></pre><h3 id="TypeScript-中的函数"><a href="#TypeScript-中的函数" class="headerlink" title="TypeScript 中的函数"></a>TypeScript 中的函数</h3>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hooks使用</title>
      <link href="/2021/07284234.html"/>
      <url>/2021/07284234.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hooks是 16.8 版本之后的新特性，React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类。<br>React 早就支持函数组件，<br>但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。<br>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。<br>Hooks可以让无状态组件实现有状态组件的部分功能，比如设置state，使用钩子函数</p><h2 id="useState-状态"><a href="#useState-状态" class="headerlink" title="useState - 状态"></a>useState - 状态</h2><pre><code>import React, &#123; Fragment, useState &#125; from &#39;react&#39;;const HooksCompont = () =&gt; &#123;  const [count, setCount] = useState(0);  return (    &lt;Fragment&gt;      &lt;h3&gt;hello hooks!! &#123;count&#125;&lt;/h3&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;加&lt;/button&gt;    &lt;/Fragment&gt;  );&#125;;export default HooksCompont;</code></pre><h2 id="useEffect-副作用"><a href="#useEffect-副作用" class="headerlink" title="useEffect - 副作用"></a>useEffect - 副作用</h2><pre><code>import React, &#123; Fragment, useState, useEffect &#125; from &#39;react&#39;;const HooksCompont = () =&gt; &#123;  const [count, setCount] = useState(0);  const [disable, setDisable] = useState(true);  // useEffect 相当于 conmponentDidMout,conmponentDidUpdate和 conmponentWillUnmount  useEffect(() =&gt; &#123;    console.log(count, &#39;页面挂载&#39;);    if (count === 2) &#123;      console.log(count, &#39;变化&#39;);    &#125;    return () =&gt; &#123;      // 这里相当于conmponentWillUnmount (页面离开时)      // 但是如果 第二参数值 发生改变时，触发副作用函数，并且执行里面逻辑      console.log(&#39;执行离开&#39;);    &#125;;    // 当 useEffect 未添加第二个参数时 ：页面每次重新渲染(任意点击按钮),都要执行一遍这些副作用函数，显然是不经济的。    // 怎么跳过一些不必要的计算呢？我们需要给 useEffect 传第二个参数即可。    // 用第二个参数来告诉 react只有当  这个参数的值 发生改变时，才执行我们传的副作用函数（第一个参数）。  &#125;, [count]);  useEffect(() =&gt; &#123;    return () =&gt; &#123;      // 这里相当于conmponentWillUnmount (页面离开时)      console.log(&#39;离开&#39;);    &#125;;  &#125;, []);  return (    &lt;Fragment&gt;      &lt;h3&gt;hello hooks!! &#123;count&#125;&lt;/h3&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;加&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setDisable(!disable)&#125;&gt;&#123;disable ? &#39;启用&#39; : &#39;禁用&#39;&#125;&lt;/button&gt;    &lt;/Fragment&gt;  );&#125;;export default HooksCompont;</code></pre><h2 id="userReducer-复杂状态处理"><a href="#userReducer-复杂状态处理" class="headerlink" title="userReducer - 复杂状态处理"></a>userReducer - 复杂状态处理</h2><pre><code>import React, &#123; Fragment, useReducer &#125; from &#39;react&#39;;const ReducerDemo = () =&gt; &#123;  const initialState = &#123; count: 0, name: &#39;鸣人&#39; &#125;;  const reducer = (state, action) =&gt; &#123;    const &#123; type, payload = 1 &#125; = action;    switch (type) &#123;      case &#39;increment&#39;:        return &#123; ...state, count: state.count + payload &#125;;      case &#39;decrement&#39;:        return &#123; ...state, count: state.count - payload &#125;;      case &#39;rename&#39;:        return &#123; ...state, name: payload &#125;;      default:        throw new Error();    &#125;  &#125;;  // 第一位参数是函数, 第二参数为初始值  // useReducer((state, action)=&gt;&#123;&#125;, 0)  // const [state, dispatch] = useReducer(reducer, initialArg);  const [state, dispatch] = useReducer(reducer, initialState);  return (    &lt;Fragment&gt;      &lt;div&gt;        useReducer &#123;state.count&#125; ---- &#123;state.name&#125;      &lt;/div&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;increment&#39; &#125;)&#125;&gt;加&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;decrement&#39;, payload: 2 &#125;)&#125;&gt;减&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#39;rename&#39;, payload: &#39;佐助&#39; &#125;)&#125;&gt;changeName&lt;/button&gt;    &lt;/Fragment&gt;  );&#125;;export default ReducerDemo;</code></pre><h2 id="useContext-深层值传递"><a href="#useContext-深层值传递" class="headerlink" title="useContext - 深层值传递"></a>useContext - 深层值传递</h2><pre><code>import React, &#123; Fragment, useState, createContext, useContext &#125; from &#39;react&#39;;// 创建 Contextconst theme = createContext(&#39;#fff&#39;);const Demo = () =&gt; &#123;  return &lt;Child /&gt;;&#125;;const Child = () =&gt; &#123;  const father = useContext(theme);  const style = &#123;    backgroundColor: father.bgColor,  &#125;;  return (    // 消费者    &lt;Fragment&gt;      &#123;/* 第一种写法 */&#125;      &lt;div style=&#123;style&#125;&gt;&#123;father.content&#125;&lt;/div&gt;      &#123;/* 第二种 使用 Consumer 属性 */&#125;      &lt;theme.Consumer&gt;&#123;(value) =&gt; &lt;div&gt;&#123;value.bgColor&#125;&lt;/div&gt;&#125;&lt;/theme.Consumer&gt;    &lt;/Fragment&gt;  );&#125;;const HooksContext = () =&gt; &#123;  // 深层值传递相当于 生产者 和 消费者模式  const [bgColor, setBgColor] = useState(&#39;#fff&#39;);  return (    &lt;Fragment&gt;      &lt;input        type=&quot;color&quot;        onChange=&#123;(e) =&gt; &#123;          setBgColor(e.target.value);        &#125;&#125;      /&gt;      &#123;/* 生产者 */&#125;      &lt;theme.Provider value=&#123;&#123; bgColor, content: 'Child' &#125;&#125;&gt;        &lt;Demo /&gt;      &lt;/theme.Provider&gt;    &lt;/Fragment&gt;  );&#125;;export default HooksContext;</code></pre><h2 id="useRef-引用"><a href="#useRef-引用" class="headerlink" title="useRef - 引用"></a>useRef - 引用</h2><pre><code>import React, &#123; Fragment, useEffect, useRef, forwardRef &#125; from &#39;react&#39;;const Input = forwardRef((prpos, ref) =&gt; &#123;  // 将ref父类的ref作为参数传入函数式组件中，本身props只带有children这个参数，这样可以让子类转发父类的ref,  // 当父类把ref挂在到子组件上时，子组件外部通过forwrardRef包裹，可以直接将父组件创建的ref挂在到子组件的某个dom元素  return &lt;input &#123;...prpos&#125; ref=&#123;ref&#125; /&gt;;&#125;);const RefDemo = () =&gt; &#123;  // 用于获取元素的原生DOM或者获取自定义组件所暴露出来的ref方法(父组件可以通过ref获取子组件，并调用相对应子组件中的方法)  const inputRef = useRef();  useEffect(() =&gt; &#123;    inputRef.current.focus();    inputRef.current.value = &#39;hello react&#39;;  &#125;, []);  return (    &lt;Fragment&gt;      &lt;Input placeholder=&quot;请输入&quot; ref=&#123;inputRef&#125; /&gt;    &lt;/Fragment&gt;  );&#125;;export default RefDemo;</code></pre><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><pre><code>import React, &#123; Fragment, useState, useMemo &#125; from &#39;react&#39;;const Child = (&#123; name, children &#125;) =&gt; &#123;  const change = () =&gt; &#123;    // 要求点击 鸣人 才执行此语句    现点击任何按钮都会执行 导致子组件重新渲染    // 原因 : 父组件任何一个状态发生变化，子组件的代码块都会重新执行一遍    window.console.log(&#39;鸣人分身&#39;);    return name;  &#125;;  //  useMemo 是在DOM更新前触发的  const actionChange = useMemo(()=&gt;change(),[name]);  return (    &lt;Fragment&gt;      &lt;div&gt;&#123;actionChange&#125;&lt;/div&gt;      &lt;div&gt;&#123;children&#125;&lt;/div&gt;    &lt;/Fragment&gt;  );&#125;;const Demo = () =&gt; &#123;  const [mingren, setMingren] = useState(&#39;鸣人&#39;);  const [zuozhu, setZuozhu] = useState(&#39;佐助&#39;);  return (    &lt;Fragment&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setMingren(mingren + 1);        &#125;&#125;      &gt;        鸣人      &lt;/button&gt;      &lt;button        onClick=&#123;() =&gt; &#123;          setZuozhu(zuozhu + 2);        &#125;&#125;      &gt;        佐助      &lt;/button&gt;      &lt;Child name=&#123;mingren&#125;&gt;&#123;zuozhu&#125;&lt;/Child&gt;    &lt;/Fragment&gt;  );&#125;;export default Demo;</code></pre><h2 id="轮播图案例"><a href="#轮播图案例" class="headerlink" title="轮播图案例"></a>轮播图案例</h2><pre><code>//轮播图数据源import React from &#39;react&#39;import Swiper from &#39;../../components/swiper&#39;class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            images: [                &#123; src: require(&quot;../../assets/images/banner1.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,                &#123; src: require(&quot;../../assets/images/banner2.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,            ]        &#125;    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;Swiper data=&#123;this.state.images&#125; /&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><pre><code>//轮播图UIimport React from &#39;react&#39;import Hoc from &#39;./hoc&#39;import &quot;./style.css&quot;export default Hoc((props) =&gt; &#123;    return (        &lt;div className=&quot;banner&quot;&gt;            &lt;div className=&quot;my-swiper-main&quot; onMouseOver=&#123;props.stop&#125; onMouseOut=&#123;props.autoPlay&#125;&gt;                &#123;                    props.data.length &gt; 0 &amp;&amp; props.data.map((item, index) =&gt; &#123;                        return (                            &lt;div className=&#123;item.active ? &quot;my-slide show&quot; : &quot;my-slide&quot;&#125; key=&#123;index&#125;&gt;                                &lt;a href=&#123;item.url&#125; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;                                    &lt;img src=&#123;item.src&#125; alt=&quot;&quot; /&gt;                                &lt;/a&gt;                            &lt;/div&gt;                        )                    &#125;)                &#125;                &lt;div className=&quot;pagination&quot;&gt;                    &#123;                        props.data.length &gt; 0 &amp;&amp; props.data.map((item, index) =&gt; &#123;                            return (                                &lt;div className=&#123;item.active ? &quot;dot active&quot; : &quot;dot&quot;&#125; key=&#123;index&#125; onClick=&#123;() =&gt; &#123; props.change(index) &#125;&#125;&gt;&lt;/div&gt;                            )                        &#125;)                    &#125;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    )&#125;)</code></pre><pre><code>//轮播图逻辑import React, &#123; useState, useEffect, useRef, useCallback &#125; from &#39;react&#39;;export default function Hoc(WithCompont) &#123;    return function HocCompont(props) &#123;        let [data, setData] = useState([]);        let [isInit, setIsInit] = useState(true)        let [iIndex, setIIndex] = useState(0)        // 创建一个表示，通用容器，专门解决 setInterval        let timer = useRef(null);        function change(index) &#123;       //点击切换图片            setIIndex(index)            if (data.length &gt; 0) &#123;                for (let i = 0; i &lt; data.length; i++) &#123;                    if (data[i].active) &#123;                        data[i].active = false;                        break;                    &#125;                &#125;            &#125;            data[index].active = true;            setData(data)        &#125;        const autoPlay = useCallback(() =&gt; &#123;      //自动播放            clearInterval(timer.current)            timer.current = setInterval(() =&gt; &#123;                let tmpIndex = iIndex;                if (data.length &gt; 0 &amp;&amp; data) &#123;                    for (let i = 0; i &lt; data.length; i++) &#123;                        if (data[i].active) &#123;                            data[i].active = false;                            break;                        &#125;                    &#125;                    if (tmpIndex &gt;= data.length - 1) &#123;                        tmpIndex = 0;                    &#125; else &#123;                        tmpIndex++                    &#125;                    data[tmpIndex].active = true;                    setIIndex(tmpIndex)                    setData(data)                &#125;            &#125;, (3000))        &#125;, [data, iIndex])  //  useState 中用到的值需要放在 第二个参数中                function stop() &#123;     //鼠标经过清除定时器            clearInterval(timer.current)           &#125;        useEffect(() =&gt; &#123;            if (props.data &amp;&amp; props.data.length &gt; 0 &amp;&amp; isInit) &#123;                setIsInit(false);                for (let i = 0; i &lt; props.data.length; i++) &#123;                    if (i === 0) &#123;                        props.data[i].active = true;                    &#125; else &#123;                        props.data[i].active = false                    &#125;                &#125;                setData(props.data); //将默认的空数组等于 props.data            &#125;            autoPlay();            return () =&gt; &#123;    //页面离开清除定时器 (页面离开时执行)                clearInterval(timer.current)            &#125;        &#125;, [props.data, isInit, autoPlay]);        let newsPros = &#123;            change: change,            data: data,            stop: stop,            autoPlay: autoPlay,        &#125;        return (            // &lt;WithCompont &#123;...props&#125; data=&#123;data&#125; change=&#123;change&#125; stop=&#123;stop&#125;&gt;&lt;/WithCompont&gt;            &lt;WithCompont &#123;...props&#125; &#123;...newsPros&#125;&gt;&lt;/WithCompont&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hooks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Native入坑</title>
      <link href="/2021/072029497.html"/>
      <url>/2021/072029497.html</url>
      
        <content type="html"><![CDATA[<h2 id="RN历史简介"><a href="#RN历史简介" class="headerlink" title="RN历史简介"></a>RN历史简介</h2><p>RN是Facebook开源的一个框架,Facebook于2015年9月15日发布React Native。广大开发者可以使用 JavaScript 和 React 开发跨平台移动应用。目前，React Native 基本实现完成了多端的支持，实现了真正意义上的面向开发配置，开发者可以灵活的使用 HTNL 和 CSS 布局，使用React语法构建组件，实现 H5 Android ios 多端代码复用  </p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h3><pre><code>npm install -g yarn     // 安装 yarnyarn -v                 // 检测是否安装成功</code></pre><h3 id="JDK安装与配置"><a href="#JDK安装与配置" class="headerlink" title="JDK安装与配置"></a>JDK安装与配置</h3><p>安卓系统的App离不开JAVA环境，因此需要下载安装JDK,到该网站下载JDK<br>选择对应自已电脑系统版本</p>]]></content>
      
      
      <categories>
          
          <category> react-native </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm初始化或安装模块报错</title>
      <link href="/2021/07187920.html"/>
      <url>/2021/07187920.html</url>
      
        <content type="html"><![CDATA[<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>报错信息如图:</p><div>    <img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/微信截图_20210718201153.png" width = 100% height = 100% /></div> <p>网上有说是版本不一致的原因，那么检测 npm 的版本</p><pre><code>npm -v更新npm版本命令:npm install npm -g 要记住全局更新cnpm install npm -g 淘宝镜像会比较快</code></pre><p>安装完之后查看npm -v，还是之前的版本，说明本地已经是最新版本了。不是版本原因<br>清除npm的缓存 </p><pre><code>npm cache clean --force</code></pre><p>然后再运行我们需要安装模块的命令<br>有时是网络问题，依赖包加载不完整，删掉node_modules文件后，重新执行 <code>npm install</code>即可</p>]]></content>
      
      
      <categories>
          
          <category> npm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="/2021/03171314.html"/>
      <url>/2021/03171314.html</url>
      
        <content type="html"><![CDATA[<!-- ### 前言由于前端知识点太多就很复杂，面试的时候有很多面试官又经常问一些偏基础的技术点，故整理此文章来帮助大家更高的应对面试，也以备自己不时之需 --><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><h4 id="Javascript-三大部分"><a href="#Javascript-三大部分" class="headerlink" title="Javascript 三大部分"></a>Javascript 三大部分</h4><ol><li>ECMAScript (JS 的语法和基本对象)</li><li>DOM (文档对象模型:处理网页内容的方法和接口)</li><li>BOM (浏览器对象模型:与浏览器交互的方法和接口)</li></ol><h4 id="Javascript-特点"><a href="#Javascript-特点" class="headerlink" title="Javascript 特点"></a>Javascript 特点</h4><p><code>解释性语言</code>:语言分为两种</p><ol><li><p>解释性语言：翻译一行执行一行，不会生成文件<br>优点：可以跨平台（windows linux ）<br>缺点：编译稍微慢</p></li><li><p>编译性语言：翻译过程为通篇翻译，看完一行，看完第二行，看完全部，生成翻译完的文件，并且执行翻译完的文件（ 列如 C C++ ）<br>优点：编译快<br>缺点：不可以跨平台</p></li></ol><p><code>单线程</code>:线程分为两种</p><ol><li>单线程（同步）：同一时间只能做一件事</li><li>多线程（异步）：同一时间做多件事</li></ol><h4 id="数据类型-—-值类型（分为两类）"><a href="#数据类型-—-值类型（分为两类）" class="headerlink" title="数据类型 —- 值类型（分为两类）"></a>数据类型 —- 值类型（分为两类）</h4><p><code>栈数据（原始值，基本数据类型）</code>：Number &emsp; String &emsp; Boolean &emsp; undefined &emsp; null &emsp; (五大类)<br>原始值存在栈里面：简单数据类型的值是储存在栈中，当把一个变量传递给另一个变量时，是把一个栈中的东西复制到另一个到栈中，并且这两个变量互不影响，修改其中的变量值时，不会改变另外一个变量的结果。</p><pre><code>var a = 1;var b = a;a = 2;console.log(a);   //2console.log(b);   //1</code></pre><p><code>堆数据（引用值）</code>: array &emsp; object &emsp; function …..<br>引用值大致存在堆里面：引用值（复杂数据类型）是把引用变量的名称（内存地址）存储在栈中，但是把其实际对象存储在堆中，栈中的内存地址指向堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针（内存地址），此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会跟着改变，  因为 JavaScript 中对象的赋值是默认引用赋值的。</p><pre><code>var a = [1];var b = a;a.push(2);console.log(a);   //[1, 2]console.log(b);   //[1, 2]</code></pre><h4 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h4><p>在一些情况下，null 和 undefined 几乎是一样的。例如：</p><pre><code>if (!undefined) &#123;// undefined is false    console.log(&#39;undefined is false&#39;);&#125;if (!null) &#123;// null is false    console.log(&#39;null is false&#39;);&#125;if(undefined == null) &#123;// true    console.log(&#39;undefined == null&#39;);&#125;</code></pre><p><strong>但是 null 和 undefined 仍然存在一些区别：</strong> 1.类型不一样<br>null 是一个 object！所以，我们可以这么理解，null 是一个对象的占位符，表示这个对象还未初始化，是个”空对象”；而 undefined 表示压根没人对这个变量做定义，没人知道这到底是个什么玩意儿。</p><pre><code>console.log(typeof undefined); //undefinedconsole.log(typeof null); //object</code></pre><p>2.转为数值时，值不一样<br>undefined 转为数值 NaN，null 转为数值 0。</p><pre><code>console.log(Number(undefined)); //NaNconsole.log(undefined + 10);//NaNconsole.log(Number(null)); //0console.log(null + 10); //10</code></pre><p><strong>null 的典型用法</strong><br>（1） 作为函数的参数，表示该函数的参数不是对象。</p><pre><code>function testObj(obj) &#123;    if(null == obj) &#123;        // 异常处理,比如创造一个新对象    &#125;&#125;</code></pre><p>（2） 作为对象原型链的终点。</p><pre><code>Object.getPrototypeOf(Object.prototype)// null</code></pre><p><strong>undefined 的典型用法</strong></p><pre><code>// (1)变量被声明了，但没有赋值时，就等于undefined。var i;i // undefined//（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。function f(x) &#123;    console.log(x)&#125;f() // undefined// (3)对象没有赋值的属性，该属性的值为undefined。var  o = new Object();o.p // undefined//（4）函数没有返回值时，默认返回undefined。var x = f();x // undefined</code></pre><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>优先级&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;运算符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;顺序&emsp;&emsp;&emsp;<br>&emsp;1&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 小括号&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ()<br>&emsp;2&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 一元运算符&emsp;&emsp;&emsp;&emsp;&emsp; ++ &emsp; – &emsp; ！<br>&emsp;3&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 算术运算符&emsp;&emsp;&emsp;&emsp;&emsp; 先&emsp; * / % &emsp;后&emsp; + -<br>&emsp;4&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 比较运算符&emsp;&emsp;&emsp;&emsp;&emsp; &gt; &emsp; &gt;=&emsp; &lt;&emsp; &lt;=<br>&emsp;5&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 相等运算符&emsp;&emsp;&emsp;&emsp;&emsp; == &emsp; !=&emsp; ===&emsp; !==&emsp;<br>&emsp;6&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 逻辑运算符&emsp;&emsp;&emsp;&emsp;&emsp; 先 &emsp; &amp;&amp; &emsp;后 &emsp; ||<br>&emsp;7&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 赋值运算符&emsp;&emsp;&emsp;&emsp;&emsp; =</p><h4 id="与-或-非-逻辑运算符"><a href="#与-或-非-逻辑运算符" class="headerlink" title="与 或 非(逻辑运算符)"></a>与 或 非(逻辑运算符)</h4><p>用来进行布尔值运算的运算符，其返回值也是布尔值（后续开发中常用于多个条件判断）<br>underfined &emsp;&emsp;&emsp;&emsp; null &emsp;&emsp;&emsp; &emsp; NaN &emsp;&emsp;&emsp; “” &emsp;&emsp;&emsp;&emsp; 0 &emsp;&emsp;&emsp;&emsp; false<br><strong>&amp;&amp; ( 与 )——短路语句</strong><br>如果表达示为假，则会返回假的第一个假值，如果表达式都为真，则会返回最后那个真值（ 碰到假就会返回该值 ）</p><pre><code>var  a  =  1  &amp;&amp;  2  &amp;&amp;  3;                    //3var  a  =  1  &amp;&amp;  0  &amp;&amp;  3;                    //0//短路作用 ：确保代码能够正常执行，常用于后端获取数据后进行判断if(data &amp;&amp; data.下面的某个属性) &#123;    ...执行代码段&#125;</code></pre><p><strong>|| ( 或 )——兼容语句</strong><br>如果表达式为真，则会返回第一个真值，如果表达式都为假，则会返回最后那个假值（碰到真就会返回该值）</p><pre><code>var  a  =  2  ||  3；                           //2var  a  =  2  ||  0  ||  3 ；                   //2var  a  =  0  ||  false ；                      //false//兼容作用 ：常用于确保代码能够多条件执行var event  =  e  ||  window.event;</code></pre><p><strong>！(非)—–取反符</strong><br>用来取布尔值在取反</p><pre><code>var  a  =  !&quot;&quot;;                                //truevar  a  =  !123;                               //falsvar obj = &#123;id:1, name:&quot;marry&quot;&#125;    if(!!obj || id !==&quot;&quot;) &#123;     console.log(obj.name)    &#125;</code></pre><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中遍历对象的几种方式</title>
      <link href="/2021/012546907.html"/>
      <url>/2021/012546907.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要介绍了JS中5种遍历对象的方式<br>我们知道，在js的对象中，有下面几种属性:</p><ul><li>可枚举属性</li><li>不可枚举属性</li><li>从原型链上继承的属性</li><li>以Symbol作为key值</li></ul><h4 id="枚举是什么"><a href="#枚举是什么" class="headerlink" title="枚举是什么"></a>枚举是什么</h4><p>枚举是指对象中的属性是否可以遍历出来，再简单点说就是属性是否可以列举出来</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组去重的几种常见写法</title>
      <link href="/2021/012228872.html"/>
      <url>/2021/012228872.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际工作或面试中，我们经常会遇到“数组去重”问题，以下来是总结的一些实现的数组去重的多种方法</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用双层循环改变原数组</p><pre><code>var arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 1, 2, 6, 6, 6, 6];function norepeat(arr) &#123;  for (var i = 0; i &lt; arr.length; i++) &#123;    for (var j = 0; j &lt; arr.length; j++) &#123;      if (arr[i] == arr[j] &amp;&amp; i != j) &#123;        arr.splice(j, 1);      &#125;    &#125;  &#125;  return arr;&#125;var arr2 = norepeat(arr);console.log(arr2);      //[1, 2, 3, 4, 5, 6]console.log(arr)        //[1, 2, 3, 4, 5, 6]</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用 es6 中Set方法，此方法最为简便</p><pre><code>let arr = [1, 4, 3, 6, 3, 4, 5, 7, 6, 2];//写法一let set = new Set(arr);let arr1 = Array.from(set); // Array.from方法可以将 Set 结构转为数组。// 写法二let arr2 = [...new Set(arr)]console.log(arr1);      //[ 1, 2, 4, 3, 6 ]console.log(arr2);      //[1, 4, 3, 6, 5, 7, 2]console.log(arr);       //[1, 4, 3, 6, 3, 4, 5, 7, 6, 2]</code></pre><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>将数组的每一个元素依次与其他元素做比较，发现重复元素，利用数组方法splice()删除重复元素</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5, 5];function norepeat(arr) &#123;  for (var i = 0; i &lt; arr.length - 1; i++) &#123;    for (var j = i + 1; j &lt; arr.length; j++) &#123;      if (arr[i] == arr[j]) &#123;        arr.splice(j, 1);        j--;      &#125;    &#125;  &#125;  return arr;&#125;var arr2 = norepeat(arr);console.log(arr2);         //[1, 23, 3, 5, 6, 7, 9, 8]console.log(arr);          //[1, 23, 3, 5, 6, 7, 9, 8]</code></pre><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>借助新数组，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中（原数组长度不变但被按字符串顺序排序）</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];function norepeat(arr) &#123;  var temp = [];  var end; //临时变量用于对比重复元素  arr.sort();  end = arr[0];  temp.push(arr[0]);  for (var i = 1; i &lt; arr.length; i++) &#123;    if (arr[i] != end) &#123;      //当前元素如果和临时元素不等则将此元素添加到新数组中      temp.push(arr[i]);      end = arr[i];    &#125;  &#125;  return temp;&#125;var arr2 = norepeat(arr);console.log(arr2);       //[1, 23, 3, 5, 6, 7, 8, 9]console.log(arr);        //[1, 1, 1, 1, 23, 23, 3, 5, 5, 6, 7, 8, 9, 9]</code></pre><h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><p>创建一个新数组，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];function norepeat(arr) &#123;  var temp = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    if (temp.indexOf(arr[i]) == -1) &#123;      temp.push(arr[i]);    &#125;  &#125;  return temp;&#125;var arr2 = norepeat(arr);console.log(arr2);      //[1, 23, 3, 5, 6, 7, 9, 8]console.log(arr);       //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5]</code></pre><h3 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h3><p>借助indexOf()方法判断此元素在该数组中首次出现的位置下标与循环的下标是否相等</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];function norepeat(arr) &#123;  for (var i = 0; i &lt; arr.length; i++) &#123;    if (arr.indexOf(arr[i]) != i) &#123;      arr.splice(i, 1); //删除数组元素后数组长度减1后面的元素前移      i--; //数组下标回退    &#125;  &#125;  return arr;&#125;var arr2 = norepeat(arr);console.log(arr2);      //[1, 23, 3, 5, 6, 7, 9, 8]console.log(arr);       //[1, 23, 3, 5, 6, 7, 9, 8]</code></pre><h3 id="方法七"><a href="#方法七" class="headerlink" title="方法七"></a>方法七</h3><p>创建一个新数组 通过indexOf方判断当前元素在数组中的索引如果与循环的下标相等则添加到新数组中</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];function norepeat(arr) &#123;  var temp = [];  for (var i = 0; i &lt; arr.length; i++) &#123;    if (arr.indexOf(arr[i]) == i) &#123;      temp.push(arr[i]);    &#125;  &#125;  return temp;&#125;var arr2 = norepeat(arr);console.log(arr2);     //[1, 23, 3, 5, 6, 7, 9, 8]console.log(arr);      //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5]</code></pre><h3 id="方法八"><a href="#方法八" class="headerlink" title="方法八"></a>方法八</h3><p>利用数组中的filter方法</p><pre><code>var arr = [1, 4, 2, 2, 3, 1, 3, 4, 5, 6, 6, 8, 9];var arr2 = arr.filter(function (value, index, self) &#123;  return self.indexOf(value) === index;&#125;);console.log(arr2);    //[1, 4, 2, 3, 5, 6, 8, 9]console.log(arr);     //[1, 4, 2, 2, 3, 1, 3, 4, 5, 6, 6, 8, 9]</code></pre><h3 id="方法九"><a href="#方法九" class="headerlink" title="方法九"></a>方法九</h3><p>利用空对象来记录新数组中已经存储过的元素</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];var obj = &#123;&#125;;var arr2 = [];for (var i = 0; i &lt; arr.length; i++) &#123;  if (!obj[arr[i]]) &#123;    obj[arr[i]] = true;    arr2.push(arr[i]);  &#125;&#125;console.log(arr2);    //[1, 23, 3, 5, 6, 7, 9, 8]console.log(arr);     //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5]</code></pre><h3 id="方法十"><a href="#方法十" class="headerlink" title="方法十"></a>方法十</h3><p>借助两个新数组</p><pre><code>var arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 2, 1, 1, 1];var arr2 = [];for (var i = 0; i &lt; arr.length; i++) &#123;  var arr3 = []; //接收重复数据后面的下标  //内层循环找出有重复数据的下标  for (var j = i + 1; j &lt; arr.length; j++) &#123;    if (arr[i] == arr[j]) &#123;      arr3.push(j); //找出后面重复数据的下标    &#125;  &#125;  // console.log(arr3);  if (arr3.length == 0) &#123;    //若重复数组没有值说明其不是重复数据    arr2.push(arr[i]);  &#125;&#125;console.log(arr2);     //[5, 4, 3, 2, 1]console.log(arr);      //[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 2, 1, 1, 1]</code></pre><h3 id="方法十一"><a href="#方法十一" class="headerlink" title="方法十一"></a>方法十一</h3><p>此方法没有借助新数组直接改变原数组,并且去重后的数组被排序</p><pre><code>var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];function norepeat(arr) &#123;  var temp;  arr.sort();  temp = arr[0];  for (var i = 1; i &lt; arr.length; i++) &#123;    if (arr[i] == temp) &#123;      //当前元素如果和临时元素相等则将此元素从数组中删除      arr.splice(i, 1);      i--;    &#125; else &#123;      temp = arr[i];    &#125;  &#125;  return arr;&#125;var arr2 = norepeat(arr);console.log(arr2);     //[1, 23, 3, 5, 6, 7, 8, 9]console.log(arr);      //[1, 23, 3, 5, 6, 7, 8, 9]</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将数组转换为数组对象</title>
      <link href="/2021/012113696.html"/>
      <url>/2021/012113696.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际开发中，我们经常需要对数据进行相应的处理，以便使用，这篇文章主要讲述如何将数组转换为数组对象格式</p><blockquote><p>原始数据：  [“苹果”, “西瓜”, “香蕉”, “梨子”]</p></blockquote><blockquote><p>需要转换为的数据： [{…}, {…}, {…}, {…}]<br>0: {id: 0, name: “苹果”}<br>1: {id: 1, name: “西瓜”}<br>2: {id: 2, name: “香蕉”}<br>3: {id: 3, name: “梨子”}</p></blockquote><blockquote><p>id，name可根据具体需求修改</p></blockquote><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><pre><code>let arr = [&quot;苹果&quot;, &quot;西瓜&quot;, &quot;香蕉&quot;, &quot;梨子&quot;];let obj = &#123;&#125;;// 将数组转化为对象for (let key in arr) &#123;  obj[key] = arr[key];&#125;newObj = Object.keys(obj).map((val) =&gt; (&#123;  id: val,  name: obj[val],&#125;));console.log(newObj);</code></pre><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><pre><code>let arr = [&quot;苹果&quot;, &quot;西瓜&quot;, &quot;香蕉&quot;, &quot;梨子&quot;];let newArr = []for(let i = 0, len = arr.length; i &lt; len; i++) &#123;  let obj = &#123;&#125;;  obj.id = i;  obj.name = arr[i];  newArr.push(obj)&#125;console.log(newArr)</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中遍历数组的几种方式</title>
      <link href="/2021/012030917.html"/>
      <url>/2021/012030917.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JS数组遍历，基本就是for,for in,forEach,for of,map等等一些方法，以下介绍几种本文分析用到的数组遍历方式</p><h3 id="第一种-普通for循环"><a href="#第一种-普通for循环" class="headerlink" title="第一种: 普通for循环"></a>第一种: 普通for循环</h3><p>最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间</p><pre><code class="js">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];for (let i = 0; i &lt; arr.length; i++) &#123;  console.log(i)         // 0 1 2 3  console.log(arr[i])    // apple banana watermelon pear&#125;</code></pre><h3 id="第二种-优化版for循环"><a href="#第二种-优化版for循环" class="headerlink" title="第二种: 优化版for循环"></a>第二种: 优化版for循环</h3><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显<br>这种方法基本上是所有循环遍历方法中性能最高的一种</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];for(let i = 0, len = arr.length; i &lt; len; i++) &#123;  console.log(i)         // 0 1 2 3  console.log(arr[i])    // apple banana watermelon pear&#125;</code></pre><h3 id="第三种-弱化版for循环"><a href="#第三种-弱化版for循环" class="headerlink" title="第三种: 弱化版for循环"></a>第三种: 弱化版for循环</h3><p>这种方法其实严格上也属于for循环，只不过是没有使用length判断，而使用变量本身判断</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];for (let i = 0; arr[i] != null; i++) &#123;  console.log(i);        // 0 1 2 3  console.log(arr[i]);   // apple banana watermelon pear&#125;</code></pre><h3 id="第四种-forEach循环"><a href="#第四种-forEach循环" class="headerlink" title="第四种: forEach循环"></a>第四种: forEach循环</h3><p>数组自带的forEach循环，使用频率较高，实际上性能比普通for循环弱</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];arr.forEach((item, index, arr) =&gt; &#123;  console.log(item);    // apple banana watermelon pear  console.log(index);   // 0 1 2 3  console.log(arr);     // 数组本身&#125;);</code></pre><h3 id="第五种-forEach变种"><a href="#第五种-forEach变种" class="headerlink" title="第五种: forEach变种"></a>第五种: forEach变种</h3><p>由于forEach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有forEach功能。<br>实际性能要比普通forEach弱</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];Array.prototype.forEach.call(arr, (item, index) =&gt; &#123;  console.log(item);    // apple banana watermelon pear  console.log(index);   // 0 1 2 3&#125;);</code></pre><h3 id="第六种-for-in循环"><a href="#第六种-for-in循环" class="headerlink" title="第六种: for in循环"></a>第六种: for in循环</h3><p>这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中它的效率是最低的</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];for (let i in arr) &#123;  console.log(i);       // 0 1 2 3  console.log(arr[i]);  // apple banana watermelon pear&#125;</code></pre><h3 id="第七种-map遍历"><a href="#第七种-map遍历" class="headerlink" title="第七种: map遍历"></a>第七种: map遍历</h3><p>这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上forEach</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];arr.map((item, index) =&gt; &#123;  console.log(item);    // apple banana watermelon pear  console.log(index);   // 0 1 2 3&#125;); </code></pre><h3 id="第八种-for-of遍历-需要ES6支持"><a href="#第八种-for-of遍历-需要ES6支持" class="headerlink" title="第八种: for of遍历(需要ES6支持)"></a>第八种: for of遍历(需要ES6支持)</h3><p>这种方式是es6里面用到的，性能要好于for in，但仍然比不上普通for循环</p><pre><code>let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];for (let value of arr) &#123;  console.log(value);  // apple banana watermelon pear&#125;</code></pre><h3 id="各种遍历方式的性能对比"><a href="#各种遍历方式的性能对比" class="headerlink" title="各种遍历方式的性能对比"></a>各种遍历方式的性能对比</h3><p>以下截图数据是，在chrome (支持es6)中运行了1000次后得出的结论(每次运行100次,一共10个循环，得到的分析结果) </p><div  align="center">    <img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/6361fb0c77ece9ce732852ee1699d60.png" width = 100% height = 100% /></div> ]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS闭包的理解</title>
      <link href="/2021/011850862.html"/>
      <url>/2021/011850862.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>闭包函数:</strong> 声明在一个函数中的函数数，叫做闭包函数<br><strong>闭包:</strong> 内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>函数嵌套函数</li><li>函数内部可以引用函数外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>让外部访问函数内部变量成为可能</li><li>局部变量会常驻在内存中</li><li>可以避免使用全局变量，防止全局变量污染</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>滥用闭包会造成内存泄露，因为闭包中引用到的包裹函数中定义的变量都永远不会被释放，所以我们应该在必要的时候，及时释放这个闭包函数。</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>最终秘诀就这一句话:</strong> 闭包找到的是同一地址中父级函数中对应变量最终的值</p><h3 id="栗子1"><a href="#栗子1" class="headerlink" title="栗子1"></a>栗子1</h3><pre><code>function funA()&#123;  var a = 10;  // funA的活动对象之中;  return function()&#123;   //匿名函数的活动对象;        alert(a);  &#125;&#125;var b = funA();b();  //10</code></pre><h3 id="栗子2"><a href="#栗子2" class="headerlink" title="栗子2"></a>栗子2</h3><pre><code>function outerFn() &#123; var i = 0; function innerFn() &#123;    i++;    console.log(i);    &#125;    return innerFn;&#125;var inner = outerFn(); //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址inner();  // 1inner();  // 2inner();  // 3var inner2 = outerFn();inner2();  // 1inner2();  // 2inner2();  // 3</code></pre><h3 id="栗子3"><a href="#栗子3" class="headerlink" title="栗子3"></a>栗子3</h3><pre><code>var i = 0;function outerFn()&#123;  function innnerFn()&#123;       i++;       console.log(i);  &#125;  return innnerFn;&#125;var inner1 = outerFn();var inner2 = outerFn();inner1(); // 1inner2(); // 2inner1(); // 3inner2(); // 4    </code></pre><h3 id="栗子4"><a href="#栗子4" class="headerlink" title="栗子4"></a>栗子4</h3><pre><code>function fn()&#123;    var a = 3;    return function()&#123;        return  ++a;                                         &#125;&#125;alert(fn()());  // 4alert(fn()());  // 4  </code></pre><h3 id="栗子5"><a href="#栗子5" class="headerlink" title="栗子5"></a>栗子5</h3><pre><code>function outerFn()&#123;var i = 0;  function innnerFn()&#123;      i++;      console.log(i);  &#125;  return innnerFn;&#125;var inner1 = outerFn();var inner2 = outerFn();inner1(); // 1inner2(); // 1inner1(); // 2inner2(); // 2</code></pre><h3 id="栗子6"><a href="#栗子6" class="headerlink" title="栗子6"></a>栗子6</h3><pre><code>(function() &#123;   var m = 0;   function getM() &#123; return m; &#125;   function seta(val) &#123; m = val; &#125;   window.g = getM;   window.f = seta; &#125;)(); f(100);console.log(g());   //100  闭包找到的是同一地址中父级函数中对应变量最终的值 </code></pre><h3 id="栗子7"><a href="#栗子7" class="headerlink" title="栗子7"></a>栗子7</h3><pre><code>function a() &#123;   var i = 0;   function b() &#123;      alert(++i)      &#125;   return b; &#125; var c = a(); c();      //1 c();      //2 </code></pre><h3 id="栗子8"><a href="#栗子8" class="headerlink" title="栗子8"></a>栗子8</h3><pre><code>function f() &#123;   var count = 0;   return  function() &#123;       count++;       console.info(count);   &#125; &#125; var t1 = f();t1();     //1 t1();     //2 t1();     //3 </code></pre><h3 id="栗子9"><a href="#栗子9" class="headerlink" title="栗子9"></a>栗子9</h3><pre><code>function m1()&#123;     var x = 1;     return function()&#123;          console.log(++x);     &#125;&#125; m1()();   //2m1()();   //2m1()();   //2 var m2 = m1();m2();   //2m2();   //3m2();   //4</code></pre><h3 id="栗子10"><a href="#栗子10" class="headerlink" title="栗子10"></a>栗子10</h3><pre><code>var  fn=(function()&#123;   var  i=10;   function  fn()&#123;      console.log(++i);   &#125;   return   fn;&#125;)() fn();   //11fn();   //12</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>务必记住的200条Git命令</title>
      <link href="/2021/01167920.html"/>
      <url>/2021/01167920.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我平时使用 Git 的时候，很多的 Git 命令我都不是很常用，工作中一般我们会配合一些可视化工具，或者编辑器自带的一些插件去维护 Git 仓库，但是我们也要记得一些常用 Git 命令来应变一些特殊的场景，下面是常用和不常用的一些 Git 命令</p><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>创建一个新的 git 版本库。这个版本库的配置、存储等信息会被保存到.git 文件夹中</p><pre><code># 初始化当前项目$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。$ git init --bare &lt;directory&gt;# 下载一个项目和它的整个代码历史# 这个命令就是将一个版本库拷贝到另一个目录中，同时也将分支都拷贝到新的版本库中。这样就可以在新的版本库中提交到远程分支$ git clone [url]</code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>管理分支，可以通过下列命令对分支进行增删改查切换等</p><pre><code># 创建一个新的分支$ git branch [branch-name]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 以上两条命令合并,新建一个分支，并切换到该分支$ git checkout -b [branch]# 查看所有的分支和远程分支$ git branch -a# 重命名分支# git branch -m &lt;旧名称&gt; &lt;新名称&gt;$ git branch -m [branch-name] [new-branch-name]# 编辑分支的介绍$ git branch [branch-name] --edit-description# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]# 切换到某个分支$ git co &lt;branch&gt;# 创建新的分支，并且切换过去$ git co -b &lt;new_branch&gt;# 基于branch创建新的new_branch$ git co -b &lt;new_branch&gt; &lt;branch&gt;# 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除$ git co $id# 把某次历史提交记录checkout出来，创建成一个分支$ git co $id -b &lt;new_branch&gt;# 删除某个分支$ git br -d &lt;branch&gt;# 强制删除某个分支 (未被合并的分支被删除的时候需要强制)$ git br -D &lt;branch&gt;</code></pre><h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><pre><code># 从远端origin的master分支更新版本库# git pull &lt;远端&gt; &lt;分支&gt;$ git pull origin master# 抓取远程仓库所有分支更新并合并到本地，不要快进合并$ git pull --no-ff</code></pre><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>显示索引文件（也就是当前工作空间）和当前的头指针指向的提交的不同</p><pre><code># 显示分支，未跟踪文件，更改和其他不同$ git status# 查看其他的git status的用法$ git help status</code></pre><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>添加文件到当前工作空间中。如果你不使用 git add 将文件添加进去，那么这些文件也不会添加到之后的提交之中</p><pre><code># 添加一个文件$ git add test.js# 添加当前目录的所有文件到暂存区$ git add .# 添加一个子目录中的文件$ git add /path/to/file/test.js# 支持正则表达式$ git add ./*.js# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>rm 和上面的 add 命令相反，从工作空间中去掉某个文件</p><pre><code># 移除 HelloWorld.js$ git rm HelloWorld.js# 移除子目录中的文件$ git rm /pather/to/the/file/HelloWorld.js# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]</code></pre><h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>将当前索引的更改保存为一个新的提交，这个提交包括用户做出的更改与信息</p><pre><code># 提交暂存区到仓库区附带提交信息$ git commit -m [message]$ git commit -m [message #指针]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><pre><code># 上传本地指定分支到远程仓库# 把本地的分支更新到远端origin的master分支上# git push &lt;远端&gt; &lt;分支&gt;# git push 相当于 git push origin master$ git push [remote] [branch]# 删除远程仓库$ git remote rm &lt;repository&gt;# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 查看远程服务器地址和仓库名称$ git remote -v# 添加远程仓库地址$ git remote add origin git@ github:xxx/xxx.git# 设置远程仓库地址(用于修改远程仓库地址)$ git remote set-url origin git@ github.com:xxx/xxx.git# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 恢复最后一次提交的状态$ git revert HEAD# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop# 列所有stash$ git stash list# 恢复暂存的内容$ git stash apply# 删除暂存区$ git stash drop</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>更改设置。可以是版本库的设置，也可以是系统的或全局的</p><pre><code># 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 输出、设置基本的全局变量$ git config --global user.email$ git config --global user.name$ git config --global user.email &quot;MyEmail@gmail.com&quot;$ git config --global user.name &quot;My Name&quot;# 定义当前用户所有提交使用的作者邮箱。$ git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;# 为Git命令创建一个快捷方式（别名）。$ git config --system core.editor &lt;editor&gt;</code></pre><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>git 内置了对命令非常详细的解释，可以供我们快速查阅</p><pre><code># 查找可用命令$ git help# 查找所有可用命令$ git help -a# 在文档当中查找特定的命令# git help &lt;命令&gt;$ git help add$ git help commit$ git help init</code></pre><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>获取某些文件，某些分支，某次提交等 git 信息</p><pre><code># 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 比较暂存区和版本库差异$ git diff --staged# 比较暂存区和版本库差异$ git diff --cached# 仅仅比较统计信息$ git diff --stat# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog# 查看远程分支$ git br -r# 创建新的分支$ git br &lt;new_branch&gt;# 查看各个分支最后提交信息$ git br -v# 查看已经被合并到当前分支的分支$ git br --merged# 查看尚未被合并到当前分支的分支$ git br --no-merged</code></pre><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>显示当前工作空间和提交的不同</p><pre><code># 显示工作目录和索引的不同$ git diff# 显示索引和最近一次提交的不同$ git diff --cached# 显示工作目录和最近一次提交的不同$ git diff HEAD</code></pre><h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><pre><code># 显示所有提交$ git log# 显示某几条提交信息$ git log -n 10# 仅显示合并提交$ git log --merges# 查看该文件每次提交记录$ git log &lt;file&gt;# 查看每次详细修改内容的diff$ git log -p &lt;file&gt;# 查看最近两次详细修改内容的diff$ git log -p -2#查看提交统计信息$ git log --stat</code></pre><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>合并就是将外部的提交合并到自己的分支中</p><pre><code># 将其他分支合并到当前分支$ git merge branchName# 在合并时创建一个新的合并后的提交# 不要 Fast-Foward 合并，这样可以生成 merge 提交$ git merge --no-ff branchName</code></pre><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>重命名或移动一个文件</p><pre><code># 重命名$ git mv test.js test2.js# 移动$ git mv test.js ./new/path/test.js# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]# 强制重命名或移动# 这个文件已经存在，将要覆盖掉$ git mv -f myFile existingFile</code></pre><h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><pre><code># 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call apply bind三者之间的区别及作用</title>
      <link href="/2020/122918266.html"/>
      <url>/2020/122918266.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到 call apply bind 这三者那就老生常谈，因为这三者之间属于高频面试题，每一次面试中基本都会有面试官问call、apply、bind的区别以及实现原理</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>call、apply、bind三者都是用来调用函数并且改变函数内部的this指向</p><h3 id="三者之间的区别"><a href="#三者之间的区别" class="headerlink" title="三者之间的区别"></a>三者之间的区别</h3><h4 id="call-与-apply"><a href="#call-与-apply" class="headerlink" title="call 与 apply"></a>call 与 apply</h4><p>其实 call 与 apply 几乎没有差别，如果有，也就传参方式不同<br><code>call</code> : 需要把实参列表按照形参列表的个数传进去<br><code>apply</code> : 需要传递一个 arguments</p><pre><code>var name = &quot;鸣人&quot;,     age = 18;var obj1 = &#123;  name: &quot;雏田&quot;,  age: 17,&#125;;var obj = &#123;  name: &quot;佐助&quot;,   age: 20,   say: function () &#123;   console.log(&quot;姓名&quot; + this.name + &quot;年龄&quot; + this.age);   &#125;,&#125;;obj.say(); // 姓名佐助年龄20  这里 obj 调用 say 方法，所以 this 指向 obj//1.非严格模式下，如果参数不传,或者第一个传递的是null/undefined,this是window//2.严格模式下：不传，this是undefinedobj.say.call();       // 姓名鸣人年龄18  此时 this 指向 windowobj.say.call(obj1);   // 姓名雏田年龄17  此时 this 指向 obj1obj.say.apply();      // 姓名鸣人年龄18  此时 this 指向 windowobj.say.apply(obj1);  // 姓名雏田年龄17  此时 this 指向 obj1//  在来看看传参方式var newobj = &#123;  name: &quot;佐助&quot;,   age: 20, myfun: function (fm, t) &#123;   console.log(this.name + &quot;年龄&quot; + this.age, &quot;来自&quot; + fm + &quot;去往&quot; + t); &#125;,&#125;;var newobj1 = &#123;  name: &quot;小樱&quot;,   age: 18,&#125;;newobj.myfun(&quot;上海&quot;,&quot;北京&quot;)                    // 佐助年龄20 来自上海去往北京newobj.myfun.call(newobj1,&quot;成都&quot;,&quot;北京&quot;)       // 小樱年龄18 来自成都去往北京newobj.myfun.apply(newobj1,[&quot;东京&quot;,&quot;上海&quot;])    // 小樱年龄18 来自东京去往上海</code></pre><h4 id="call-与-bind"><a href="#call-与-bind" class="headerlink" title="call 与 bind"></a>call 与 bind</h4><p><code>call</code>: 不需要调用，自执行<br><code>bind</code>: 返回的是一个新的函数，你必须调用它才会被执行</p><pre><code>var newobj = &#123;  name: &quot;佐助&quot;,   age: 20, myfun: function (fm, t) &#123;   console.log(this.name + &quot;年龄&quot; + this.age, &quot;来自&quot; + fm + &quot;去往&quot; + t); &#125;,&#125;;var newobj1 = &#123;  name: &quot;小樱&quot;,   age: 18,&#125;;newobj.myfun.call(newobj1,&#39;巴黎&#39;, &#39;东京&#39;)      // 小樱年龄18 来自巴黎去往东京newobj.myfun.bind(newobj1,&#39;上海&#39;, &#39;成都&#39;)()    // 小樱年龄18 来自上海去往成都newobj.myfun.bind(newobj1,[&#39;上海&#39;, &#39;成都&#39;])()  // 小樱年龄18 来自上海,成都去往undefined</code></pre><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><pre><code>function fn(a, b) &#123;    this.c = 3    console.log(a, b, this)&#125;fn(1, 2) //  打印1, 2, Windowconsole.log(c) //  打印3const obj = &#123;d: 4&#125;fn.call(obj, 1, 2) //  打印1, 2, &#123;d: 4&#125;fn.apply(obj, [1, 2]) //  打印1, 2, &#123;d: 4&#125;fn.call(null, 1, 2) //  打印1, 2, windowfn.call(undefined, 1, 2) //  打印1, 2, windowfn.bind(obj)(1, 2) //  打印1,2，&#123;d: 4&#125;fn.bind(obj, 5)(1, 2) //  打印5, 1, &#123;d: 4&#125;fn.bind(obj, 5, 3)(1, 2) //  打印5, 3, &#123;d: 4&#125; </code></pre><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code>Function.prototype.call = function (obj, ...args) &#123;    // 错误写法，有同学问fn调用call，那么这里的this是指向fn，直接调用函数并传入参数不就可以了吗？    // this(...args)        // 上面这种写法，并不能改变fn函数内部的this指向，所以不符合的我们的需求。我们应该是让obj去调用fn函数，才能让fn指向obj        // 1. 处理obj是undefined或者null的情况    if (obj === undefinded || obj === null) &#123;        obj = window    &#125;            // 2. 给obj添加一个方法tmpFn，等于fn函数    obj.tmpFn = this        // 3. 调用obj的tmpFn的方法，并保存执行结果，此时fn函数中this指向obj    const result = obj.tmpFn(...args)        // 4. 删除obj上的tmpFn    delete obj.tmpFn        // 5. 返回方法的返回值    return result&#125;Function.prototype.apply = function (obj, args) &#123;    // 1. 处理obj是undefined或者null的情况    if (obj === undefinded || obj === null) &#123;        obj = window    &#125;    // 2. 给obj添加一个方法tmpFn，等于fn函数    obj.tmpFn = this        // 3. 调用obj的tmpFn的方法    const result = obj.tmpFn(args)        // 4. 删除obj上的tmpFn    delete obj.tmpFn        // 5. 返回方法的返回值    return result&#125;Function.prototype.bind = function (obj, ...args) &#123;    // 1. 返回一个新函数，这里采用es6 箭头函数写法，不懂的同学自行学习    return (...args2) =&gt; &#123;        // 2. 调用原来函数，改变this指向obj，参数列表由args和args2依次组成。        return this.call(obj, ...args, ...args2) // 这里this.call的this指向的是fn函数，也就是调用bind的函数。    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中的浅拷贝与深拷贝</title>
      <link href="/2020/122735313.html"/>
      <url>/2020/122735313.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用；<br>深拷贝是拷贝多层，每一级别的数据都会拷贝出来；<br><strong>总结来看 :</strong><br>浅拷贝的时候如果数据是基本数据类型，那么就如同直接赋值那种，会拷贝其本身，如果除了基本数据类型之外还有一层对象，那么对于浅拷贝而言就只能拷贝其引用，对象的改变会反应到拷贝对象上；但是深拷贝就会拷贝多层，即使是嵌套了对象，也会都拷贝出来。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h4><pre><code>var a = &#123;x : 1&#125;var b = aconsole.log(b)    // &#123;x:1&#125;b.x = 2console.log(a)   // &#123;x:2&#125;console.log(b)   // &#123;x:2&#125;</code></pre><h4 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h4><pre><code>var obj = &#123;    name: &quot;abc&quot;,    num: [1,2,3,4,5],  &#125;var obj1 = &#123;&#125;for (var prop in obj) &#123;       //用遍历的方式将 obj 的数据拷贝给 obj1    obj1[prop] = obj[prop]&#125;obj1.num[4] = 8console.log(obj.num[4])    //此时可以看见 obj 的数据也进行了改变    8</code></pre><p><strong>上述案例可以看出:</strong> 浅拷贝是一个传址,也就是把 a 的值赋给 b 的时候同时也把 a 的址赋给了 b,当 a || b 的值改变的时候， a || b 的值也同时会改变, 实现浅拷贝的方法很多，这里不多讲，在来看看重点深拷贝</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="实现方式一-1"><a href="#实现方式一-1" class="headerlink" title="实现方式一"></a>实现方式一</h4><p><strong>使用递归复制所有层级属性</strong></p><pre><code>function deepClone(obj) &#123;  let objClone = Array.isArray(obj) ? [] : &#123;&#125;;  if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123;    for (let key in obj) &#123;      if (obj.hasOwnProperty(key)) &#123;        // 判断obj子元素是否为对象，如果是，递归复制        if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;          objClone[key] = deepClone(obj[key]);        &#125; else &#123;          objClone[key] = obj[key];        &#125;      &#125;    &#125;  &#125;  return objClone;&#125;let a = [1, 2, 3, 4, [5, 6]];let b = deepClone(a); a[4][0] = 0;console.log(a);  // [1, 2, 3, 4, [0, 6]]console.log(b);  // [1, 2, 3, 4, [5, 6]]</code></pre><h4 id="实现方式二-1"><a href="#实现方式二-1" class="headerlink" title="实现方式二"></a>实现方式二</h4><p><strong>通过 JSON 对象实现深拷贝</strong></p><pre><code>function deepClone (obj) &#123;  let _obj = JSON.stringify(obj)  let objClone = JSON.parse(_obj)  return objClone&#125;let a = [0,1,[2,3],4]let b = deepClone(a)a[0] = 1  a[2][0] = 1console.log(a)  // [1,1,[1,3],4]console.log(b)  // [0,1,[2,3],4]</code></pre><h4 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h4><p><strong>使用 JQ 的 extend 方法</strong></p><pre><code>$.extend([deep ], target, object1 [, objectN ])</code></pre><p>deep表示是否深拷贝，为true为深拷贝；为false，为浅拷贝。</p><p>target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。</p><p>object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。</p><pre><code>let a = [0,1,[2,3],4]let b = $.extend(true, [], a)a[0] = 1a[2][0] = 1console.log(a)  // [1,1,[1,3],4]console.log(b)  // [0,1,[2,3],4]</code></pre><p><strong>以上几种方法可完全实现深度拷贝，下面还有几种是不完全实现深度拷贝</strong></p><h3 id="浅深拷贝"><a href="#浅深拷贝" class="headerlink" title="浅深拷贝"></a>浅深拷贝</h3><p><strong>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</strong></p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>使用扩展运算符实现深拷贝</strong></p><pre><code>var obj = &#123; a: 1,b: &#123;c:2&#125;&#125;var newObj = &#123; ...obj &#125;obj.a = 2obj.b.c = 0console.log(obj);     // &#123; a: 2,b: &#123;c:0&#125;&#125;console.log(newObj)   // &#123; a: 1,b: &#123;c:0&#125;&#125;</code></pre><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>数组中 slice 方法</strong></p><pre><code>let a = [0,1,[2,3],4]let b = a.slice()a[0] = 1a[2][0] = 1console.log(a)  // [1,1,[1,3],4]console.log(b)  // [0,1,[1,3],4]</code></pre><p><strong>同理数组中的 concat 方法也会实现上述情况</strong></p><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p><strong>通过使用 Object.assign() 实现</strong></p><pre><code>const objA = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;const objB = &#123; name: &quot;xixi&quot; &#125;;const obj = Object.assign(&#123;&#125;,objA, objB);objA.a = 2;objA.b.c = 3;objB.name = &quot;haha&quot;;console.log(objA);  //  &#123; a: 2, b: &#123; c: 3 &#125; &#125;;console.log(objB);  //   &#123; name: &quot;haha&quot; &#125;;console.log(obj);   // &#123; a: 1, b: &#123; c: 3 &#125;, name : &quot;xixi&quot; &#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浅拷贝 </tag>
            
            <tag> 深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星空特效</title>
      <link href="/2020/122024884.html"/>
      <url>/2020/122024884.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看到自己的电脑桌面是太空的界面，于是心血来潮，便有心次制作星空特效。<br>每次刷新页面都会生成新的页面</p><h3 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h3><div  align="center">    <img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/2020-12-20 191248.jpg" width = 100% height = 100% /></div> <h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;太空&lt;/title&gt;    &lt;style&gt;        body&#123;            width: 100%;            height: 1000px;            background: linear-gradient(to bottom right, #000, #2073c2 60%, #dff6ff);            overflow: hidden;        &#125;        span&#123;            display: block;            position: absolute;            border-radius: 50%;            box-shadow: 0.4px 0.4px 0.4px 0px #fff;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;    window.onload = function()&#123;        var screenW = document.documentElement.clientWidth;        var screenH = document.documentElement.clientHeight;        var colorArr = [&#39;#fff&#39;,&#39;skyblue&#39;,&#39;orange&#39;];        for( var i=0; i&lt;800; i++ )&#123;            var span = document.createElement(&#39;span&#39;);            var width = Math.random() * 3;            var colorIndex = parseInt(Math.random() * 3);            var x = parseInt(Math.random() * screenW);            var y = parseInt(Math.random() * screenH);            span.style.width = parseInt(width) + &#39;px&#39;;            span.style.height = parseInt(width) + &#39;px&#39;;            span.style.background = colorArr[colorIndex];            span.style.left = x + &#39;px&#39;;            span.style.top = y + &#39;px&#39;;             document.body.appendChild(span);        &#125;    &#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 炫酷特效 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小星星特效</title>
      <link href="/2020/12207920.html"/>
      <url>/2020/12207920.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是使用原生 JS 实现的一款鼠标经过特效，实现效果如下图</p><h3 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h3><div  align="center">    <img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/屏幕截图 2020-12-20 185425.jpg" width = 50% height = 50% /></div> <h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code>    &lt;script&gt;      //鼠标经过小星星特效      (function fairyDustCursor() &#123;        var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;];        var width = window.innerWidth;        var height = window.innerHeight;        var cursor = &#123; x: width / 2, y: width / 2 &#125;;        var particles = [];        function init() &#123;          bindEvents();          loop();        &#125;        // Bind events that are needed        function bindEvents() &#123;          document.addEventListener(&quot;mousemove&quot;, onMouseMove);          document.addEventListener(&quot;touchmove&quot;, onTouchMove);          document.addEventListener(&quot;touchstart&quot;, onTouchMove);          window.addEventListener(&quot;resize&quot;, onWindowResize);        &#125;        function onWindowResize(e) &#123;          width = window.innerWidth;          height = window.innerHeight;        &#125;        function onTouchMove(e) &#123;          if (e.touches.length &gt; 0) &#123;            for (var i = 0; i &lt; e.touches.length; i++) &#123;              addParticle(                e.touches[i].clientX,                e.touches[i].clientY,                possibleColors[                  Math.floor(Math.random() * possibleColors.length)                ]              );            &#125;          &#125;        &#125;        function onMouseMove(e) &#123;          cursor.x = e.clientX;          cursor.y = e.clientY;          addParticle(            cursor.x,            cursor.y,            possibleColors[Math.floor(Math.random() * possibleColors.length)]          );        &#125;        function addParticle(x, y, color) &#123;          var particle = new Particle();          particle.init(x, y, color);          particles.push(particle);        &#125;        function updateParticles() &#123;          // Updated          for (var i = 0; i &lt; particles.length; i++) &#123;            particles[i].update();          &#125;          // Remove dead particles          for (var i = particles.length - 1; i &gt;= 0; i--) &#123;            if (particles[i].lifeSpan &lt; 0) &#123;              particles[i].die();              particles.splice(i, 1);            &#125;          &#125;        &#125;        function loop() &#123;          requestAnimationFrame(loop);          updateParticles();        &#125;        /**         * Particles         */        function Particle() &#123;          this.character = &quot;*&quot;;          this.lifeSpan = 120; //ms          this.initialStyles = &#123;            position: &quot;fixed&quot;,            top: &quot;0&quot;, //必须加            display: &quot;block&quot;,            pointerEvents: &quot;none&quot;,            &quot;z-index&quot;: &quot;10000000&quot;,            fontSize: &quot;20px&quot;,            &quot;will-change&quot;: &quot;transform&quot;,          &#125;;          // Init, and set properties          this.init = function (x, y, color) &#123;            this.velocity = &#123;              x: (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2),              y: 1,            &#125;;            this.position = &#123; x: x - 10, y: y - 20 &#125;;            this.initialStyles.color = color;            this.element = document.createElement(&quot;span&quot;);            this.element.innerHTML = this.character;            applyProperties(this.element, this.initialStyles);            this.update();            document.body.appendChild(this.element);          &#125;;          this.update = function () &#123;            this.position.x += this.velocity.x;            this.position.y += this.velocity.y;            this.lifeSpan--;            this.element.style.transform =              &quot;translate3d(&quot; +              this.position.x +              &quot;px,&quot; +              this.position.y +              &quot;px,0) scale(&quot; +              this.lifeSpan / 120 +              &quot;)&quot;;          &#125;;          this.die = function () &#123;            this.element.parentNode.removeChild(this.element);          &#125;;        &#125;        /**         * Utils         */        // Applies css `properties` to an element.        function applyProperties(target, properties) &#123;          for (var key in properties) &#123;            target.style[key] = properties[key];          &#125;        &#125;        init();      &#125;)();    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 炫酷特效 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中this指向问题</title>
      <link href="/2020/12193329.html"/>
      <url>/2020/12193329.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>面向对象语言中 this 表示当前对象的一个引用,但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p><h3 id="1-全局作用域或者普通函数中-this-指向全局对象-window"><a href="#1-全局作用域或者普通函数中-this-指向全局对象-window" class="headerlink" title="1. 全局作用域或者普通函数中 this 指向全局对象 window"></a>1. 全局作用域或者普通函数中 this 指向全局对象 window</h3><pre><code>//直接打印var a = 10;console.log(this.a)</code></pre><blockquote><p>10</p></blockquote><pre><code>//function声明函数var a = 10;function bar() &#123;  var a = 20  console.log(this.a);&#125;bar();</code></pre><blockquote><p>10</p></blockquote><pre><code>//function声明函数赋给变量var a = 10;var bar = function () &#123;  var a = 20;  console.log(this.a);&#125;;bar();</code></pre><blockquote><p>10</p></blockquote><pre><code>//立即执行函数var a = 10;(function () &#123;  var a = 20;  console.log(this.a);&#125;)();</code></pre><blockquote><p>10</p></blockquote><pre><code>//定时器方法var a = 10;setInterval(function () &#123;    var a = 20  console.log(this.a);&#125;, 2000);</code></pre><blockquote><p>10</p></blockquote><h3 id="2-方法调用中谁调用-this-指向谁"><a href="#2-方法调用中谁调用-this-指向谁" class="headerlink" title="2. 方法调用中谁调用 this 指向谁"></a>2. 方法调用中谁调用 this 指向谁</h3><pre><code>//对象方法调用var a = 10;var person = &#123;  a: 20,  run: function () &#123;    console.log(this.a);  &#125;,&#125;;person.run();</code></pre><blockquote><p>20</p></blockquote><pre><code>&lt;!-- 事件绑定 --&gt;&lt;button type=&quot;button&quot;&gt;点我&lt;/button&gt;&lt;script&gt;  var btn = document.querySelector(&quot;button&quot;);  btn.onclick = function () &#123;    console.log(this);  &#125;;&lt;/script&gt;</code></pre><blockquote><p>&lt; button button button type=”button”&gt;点我 &lt; /button&gt;</p></blockquote><pre><code>&lt;!-- 事件监听 --&gt;&lt;button type=&quot;button&quot;&gt;点我&lt;/button&gt;&lt;script&gt;  var btn = document.querySelector(&quot;button&quot;);  btn.addEventListener(&quot;click&quot;, function () &#123;    console.log(this);  &#125;);&lt;/script&gt;</code></pre><blockquote><p>&lt; button button button type=”button”&gt;点我 &lt; /button&gt;</p></blockquote><h3 id="3-在构造函数或者构造函数原型对象中-this-指向构造函数的实例"><a href="#3-在构造函数或者构造函数原型对象中-this-指向构造函数的实例" class="headerlink" title="3. 在构造函数或者构造函数原型对象中 this 指向构造函数的实例"></a>3. 在构造函数或者构造函数原型对象中 this 指向构造函数的实例</h3><pre><code>//不使用new指向windowfunction Person(name) &#123;  console.log(this)     // window  this.name = name;&#125;Person(&#39;inwe&#39;)//使用newfunction Person(name) &#123;  this.name = name  console.log(this)     //people  self = this&#125;var people = new Person(&#39;iwen&#39;)console.log(self === people)       //true//这里new改变了this指向，将this由window指向Person的实例对象people</code></pre><blockquote><p>window<br>people<br>true</p></blockquote><h3 id="4-箭头函数中指向外层作用域的-this"><a href="#4-箭头函数中指向外层作用域的-this" class="headerlink" title="4. 箭头函数中指向外层作用域的 this"></a>4. 箭头函数中指向外层作用域的 this</h3><pre><code>var obj = &#123;  foo() &#123;    console.log(this);  &#125;,  bar: () =&gt; &#123;    console.log(this);  &#125;&#125;obj.foo()    // &#123;foo: ƒ, bar: ƒ&#125;obj.bar()    // window</code></pre><blockquote><p>{foo: ƒ, bar: ƒ}<br>window</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中使用axios发送请求</title>
      <link href="/2020/121850332.html"/>
      <url>/2020/121850332.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP client</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>从浏览器创建 XMLHttpRequests</li><li>从node.js 发出 http 请求</li><li>支持 Promise API</li><li>拦截请求(request) 和响应(response)</li><li>转换请求和响应数据</li><li>终止请求</li><li>自动转换 JSON 数据</li><li>Client 端支持防范 XSRF</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>npm install axios --save</code></pre><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><pre><code>import React from &#39;react&#39;;import axios from &#39;axios&#39;     // 第一步引入 axiosclass App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            navs: [],        &#125;    &#125;    componentDidMount() &#123;    // 第二步在此生命周期函数中发送请求        // axios后面直接跟 url 地址 ， 在使用 .then方法        axios.get(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;).then((res) =&gt; &#123;            console.log(res)            if (res.status === 200) &#123;                this.setState(&#123; navs: res.data.data &#125;)            &#125; else &#123;                alert(&quot;请求失败&quot;)            &#125;        &#125;)    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;ul&gt;                    &#123;this.state.navs.map((item, index) =&gt; &#123;    // 第三步渲染数据                        return (                            &lt;li key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/li&gt;                        )                    &#125;)&#125;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><pre><code>import React from &#39;react&#39;;import axios from &#39;axios&#39;     // 第一步引入 axiosclass App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            phone: &quot;&quot;,            password: &quot;&quot;,        &#125;    &#125;    componentDidMount() &#123;        // 第二步在此生命周期函数中发送请求        // axios后面直接跟 url 地址 ， 在使用 .then方法        axios.post(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;, &#123;            // 第三步传递需要的数据      clellphone,    password这是需要传递的数据            clellphone: this.state.phone,            password: this.state.password        &#125;).then((res) =&gt; &#123;            if (res.status === 200) &#123;               console.log(&quot;请求成功&quot;,res)            &#125; else &#123;                alert(&quot;请求失败&quot;)            &#125;        &#125;)    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><h3 id="上传本地文件"><a href="#上传本地文件" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><pre><code>import React from &#39;react&#39;;import axios from &#39;axios&#39;     // 第一步引入 axiosclass App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            num: 0,        &#125;    &#125;    upHead(e) &#123;        let headFile = e.target.files[0];        let data = new FormData();        data.append(&quot;headfile&quot;, headFile);        var config = &#123;            onUploadProgress: (progressEvent) =&gt; &#123;                // 进度条                var percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);                this.setState(&#123; num: percentCompleted &#125;, () =&gt; &#123;                    if (this.state.num === 100) &#123;                        this.setState(&#123; num: 0 &#125;)                    &#125;                &#125;)            &#125;        &#125;;        axios.post(&quot;http://vueshop.glbuys.com/api/user/myinfo/formdatahead?token=1ec949a15fb709370f&quot;,            data, config).then(res =&gt; &#123;                console.log(res);                if (res.data.code === 200) &#123;                    this.setState(&#123; showHead: &quot;http://vueshop.glbuys.com/userfiles/head/&quot; + res.data.data.msbox &#125;)                &#125;            &#125;)    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                上传头像 : &lt;input type=&quot;file&quot; onChange=&#123;this.upHead.bind(this)&#125; /&gt; &lt;br /&gt;                 头像预览 : &#123;this.state.showHead !== &quot;&quot; ? &lt;img src=&#123;this.state.showHead&#125; alt=&quot;&quot; style=&#123;&#123; width: 200, height: 200 &#125;&#125; /&gt; : &quot;&quot;&#125;&lt;br /&gt;                 进度条预览 : &lt;div style=&#123;&#123; width: 300, height: 25, border: 1, &#125;&#125;&gt;                    &lt;div style=&#123;&#123; height: 100 + '%', width: this.state.num + "%", background: "green" &#125;&#125;&gt;&lt;/div&gt;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><h2 id="封装请求"><a href="#封装请求" class="headerlink" title="封装请求"></a>封装请求</h2><p>建立 reques.js文件，内容如下:</p><pre><code>import axios from &#39;axios&#39;export function request(url, method = &quot;get&quot;, data = &#123;&#125;, config = &#123;&#125;) &#123;    return axiosRequest(url, method, data, config)&#125;function axiosRequest(url, method, data, config) &#123;    if (method.toLocaleLowerCase() === &quot;post&quot;) &#123;        let params = new URLSearchParams();               if (data instanceof Object) &#123;              //如果后端格式为 raw    从此开始注释            for (let key in data) &#123;                params.append(key, data[key]);            &#125;            data = params;                        // 此处注释结束        &#125;                           &#125; else if (method.toLocaleLowerCase() === &quot;file&quot;) &#123;        method = &quot;post&quot;;        let params = new FormData();        if (data instanceof Object) &#123;            for (let key in data) &#123;                params.append(key, data[key]);            &#125;            data = params;        &#125;    &#125;    let axiosConfig = &#123;        url: url,        method: method.toLocaleLowerCase(),        data: data    &#125;;    if (config instanceof Object) &#123;        for (let key in config) &#123;            axiosConfig[key] = config[key];        &#125;    &#125;    return axios(axiosConfig).then(res =&gt; res.data);&#125;</code></pre><h3 id="GET请求-1"><a href="#GET请求-1" class="headerlink" title="GET请求"></a>GET请求</h3><pre><code>import React from &#39;react&#39;;import &#123; request &#125; from &#39;../../utils/reques&#39;;    // 第一步引入方法class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            navs: [],        &#125;    &#125;    componentDidMount() &#123;    // 第二步在此生命周期函数中发送请求        // 调用此方法，第一位参数为请求地址，第二位参数为请求方式        request(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;,&quot;get&quot;).then(res =&gt; &#123;            if (res.code === 200) &#123;                this.setState(&#123; navs: res.data &#125;)            &#125; else &#123;                alert(&quot;请求失败&quot;)            &#125;        &#125;)    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;ul&gt;                    &#123;this.state.navs.map((item, index) =&gt; &#123;    // 第三步渲染数据                        return (                            &lt;li key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/li&gt;                        )                    &#125;)&#125;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><h3 id="POST请求-1"><a href="#POST请求-1" class="headerlink" title="POST请求"></a>POST请求</h3><pre><code>import React from &#39;react&#39;;import &#123; request &#125; from &#39;../../utils/reques&#39;;       // 第一步引入方法class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            phone: &quot;&quot;,            password: &quot;&quot;,        &#125;    &#125;    componentDidMount() &#123;        // 第二步在此生命周期函数中发送请求        // 调用此方法，第一位参数为请求地址，第二位参数为请求方式，第三位参数为需要传递的数据        request(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;, &quot;post&quot;, &#123;            clellphone: this.state.phone,            password: this.state.password        &#125;.then((res) =&gt; &#123;            if (res.code === 200) &#123;                this.props.dispatch(actions.user.login(&#123; username: this.state.username, isLogin: true &#125;))            &#125; else &#123;                alert(&quot;请求失败&quot;)            &#125;        &#125;))    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><h3 id="上传本地文件-1"><a href="#上传本地文件-1" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><pre><code>import React from &#39;react&#39;;import &#123; request &#125; from &#39;../../utils/reques&#39;;    // 第一步引入方法class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            num: 0,        &#125;    &#125;    upHead(e) &#123;        let headFile = e.target.files[0];        var config = &#123;            onUploadProgress: (progressEvent) =&gt; &#123;                // 进度条                var percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);                this.setState(&#123; num: percentCompleted &#125;, () =&gt; &#123;                    if (this.state.num === 100) &#123;                        this.setState(&#123; num: 0 &#125;)                    &#125;                &#125;)            &#125;        &#125;;         // 调用此方法，第一位参数为请求地址，第二位参数为请求方式,这里 file 方法中改为为了 post        request(&quot;http://vueshop.glbuys.com/api/user/myinfo/formdatahead?token=1ec949a15fb709370f&quot;, &quot;file&quot;, &#123;            headfile: headFile        &#125;, config).then(res =&gt; &#123;            if (res.code === 200) &#123;                this.setState(&#123; showHead: &quot;http://vueshop.glbuys.com/userfiles/head/&quot; + res.data.msbox &#125;)            &#125; else &#123;                alert(&quot;请求失败&quot;)            &#125;        &#125;)    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                上传头像 : &lt;input type=&quot;file&quot; onChange=&#123;this.upHead.bind(this)&#125; /&gt; &lt;br /&gt;                 头像预览 : &#123;this.state.showHead !== &quot;&quot; ? &lt;img src=&#123;this.state.showHead&#125; alt=&quot;&quot; style=&#123;&#123; width: 200, height: 200 &#125;&#125; /&gt; : &quot;&quot;&#125;&lt;br /&gt;                 进度条预览 : &lt;div style=&#123;&#123; width: 300, height: 25, border: 1, &#125;&#125;&gt;                    &lt;div style=&#123;&#123; height: 100 + '%', width: this.state.num + "%", background: "green" &#125;&#125;&gt;&lt;/div&gt;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React实现数据双向绑定</title>
      <link href="/2020/121351352.html"/>
      <url>/2020/121351352.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双向数据绑定，带来双向数据流。数据（state）和视图（View）之间的双向绑定。<br>说到底就是 （value 的单向绑定 + onChange 事件侦听）的一个语法糖<br><strong>特点:</strong> 无论数据改变，或是用户操作，都能带来互相的变动，自动更新。适用于项目细节</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            amount: 0        &#125;    &#125;    changeAmout(e) &#123;        this.setState(&#123; amount: e.target.value &#125;)    &#125;    render() &#123;        return (            &lt;div&gt;                数量 ：&lt;input type=&quot;text&quot; value=&#123;this.state.amount&#125; onChange=&#123;(event)=&gt;&#123;                    this.changeAmout(event)                &#125;&#125;/&gt;                &lt;br/&gt;                数量值 : &#123;this.state.amount&#125;            &lt;/div&gt;        )    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向绑定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中数组的使用及方法</title>
      <link href="/2020/12133498.html"/>
      <url>/2020/12133498.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><font face="微软雅黑" size=5><strong>什么是数组</strong></font><br>数组对象是使用单独的变量名来存储一系列的值。简单意思就是普通变量一次只能储存一个值，数组可以储存多个值<br>如果你有一组数据（例如：车名字），存在单独变量如下所示:</p><pre><code>var car1=&quot;奔驰&quot;;var car2=&quot;奥迪&quot;;var car3=&quot;宝马&quot;;</code></pre><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p><font face="微软雅黑" size=5><strong>创建一个数组有3种方式</strong></font><br><strong>方式一 : 常规方式</strong></p><pre><code>var myCars = new Array();myCars[0]=&quot;奔驰&quot;myCars[1]=&quot;奥迪&quot;myCars[2]=&quot;宝马&quot;</code></pre><p><strong>方式二 : 简洁方式</strong></p><pre><code>var myCars=new Array(&quot;奔驰&quot;,&quot;奥迪&quot;,&quot;宝马&quot;);</code></pre><p><strong>方式三 : 字面 (常用)</strong> </p><pre><code>var myCars=[&quot;奔驰&quot;,&quot;奥迪&quot;,&quot;宝马&quot;];</code></pre><h2 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h2><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p><strong>返回创建数组对象原型的函数</strong><br>返回myCars数组对象原型创建的函数：</p><pre><code>var myCars = [&quot;奔驰&quot;, &quot;奥迪&quot;, &quot;宝马&quot;]myCars.constructor</code></pre><p><strong>结果输出:</strong></p><blockquote><p>function Array() { [native code] }</p></blockquote><p><strong>在JavaScript中，constructor属性返回对象的构造函数。</strong><br><strong>返回值是函数的引用，不是函数名:</strong></p><blockquote><p>JavaScript 数组 constructor 属性返回 function Array() { [native code] }<br>JavaScript 数字 constructor 属性返回 function Number() { [native code] }<br>JavaScript 字符串 constructor 属性返回 function String() { [native code] }</p></blockquote><h3 id="lenght"><a href="#lenght" class="headerlink" title="lenght"></a>lenght</h3><p><strong>设置或返回数组元素的个数。</strong></p><pre><code>var myCars = [&quot;奔驰&quot;, &quot;奥迪&quot;, &quot;宝马&quot;]myCars.length</code></pre><p><strong>结果输出:</strong></p><blockquote><p>3</p></blockquote><p><strong>设置数组的数目：array.length=number</strong></p><pre><code>var myCars = [&quot;奔驰&quot;, &quot;奥迪&quot;, &quot;宝马&quot;]myCars.length=10console.log(myCars.length) console.log(myCars) console.log(myCars[5])</code></pre><p><strong>结果输出:</strong></p><blockquote><p>10<br>[“奔驰”, “奥迪”, “宝马”, empty × 7] &emsp; &emsp; &emsp; 后面为空值<br>undefined</p></blockquote><h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p><strong>允许你向数组对象添加属性或方法</strong><br><strong>添加一个新的数组的方法，将数组值转为大写：</strong></p><pre><code>var fruits=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;]Array.prototype.myUcase = function () &#123;    for (i = 0; i &lt; this.length; i++) &#123;        this[i] = this[i].toUpperCase();      //toUpperCase() 方法用于把字符串转换为大写    &#125;&#125;fruits.myUcase();</code></pre><p><strong>结果输出:</strong></p><blockquote><p>[“BANANA”, “ORANGE”, “APPLE”, “MANGO”]</p></blockquote><h2 id="Array-对象方法"><a href="#Array-对象方法" class="headerlink" title="Array 对象方法"></a>Array 对象方法</h2><p><strong>数组总共有30种方法</strong></p><h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><strong>把数组转换为字符串</strong></p><pre><code>var arr = [1, 2, 3, 4]var sum = arr.toString()console.log(sum)</code></pre><p><strong>输出结果 :</strong></p><blockquote><p>1,2,3,4,     字符串类型</p></blockquote><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p><strong>连接两个或更多的数组，并返回结果</strong></p><pre><code>var fruits1 = [&quot;Banana&quot;, &quot;Orange&quot;,]var fruits2 = [&quot;Apple&quot;,&quot;Mango&quot;,]var fruits3 = [&quot;watermelon&quot;,&quot;pear&quot;,]var fruits = fruits1.concat(fruits2,fruits3)</code></pre><p><strong>fruits 输出结果:</strong></p><blockquote><p> [“Banana”, “Orange”, “Apple”, “Mango”, “watermelon”, “pear”]</p></blockquote><h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><p><strong>返回数组的可迭代对象</strong><br><strong>简单说就是 Object.entries() 可以把一个对象的键值以数组的形式遍历出来，迭代对象中数组的索引值作为 key，数组元素作为 value。结果和 for…in 一致，但不会遍历原型属性</strong><br><strong>1. 传入对象</strong></p><pre><code>var obj = &#123;name: &#39;雏田&#39;,age: 18&#125;var x = Object.entries(obj)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>[[‘name’, ‘雏田’], [‘age’, 18]]</p></blockquote><p><strong>2. 传入数组</strong></p><pre><code>var arr =  [&quot;鸣人&quot;, &quot;雏田&quot;, &quot;佐助&quot;]; var x = Object.entries(arr)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>[[‘0’, “鸣人”], [‘1’, ‘雏田’], [‘2’, ‘佐助’]]</p></blockquote><p><strong>3. 传入数组中包含对象</strong></p><pre><code>var arr =  [&#123;name:&quot;鸣人&quot;&#125;, &quot;雏田&quot;, &quot;佐助&quot;]; var x = Object.entries(arr)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>[[‘0’, { name: “鸣人” }], [‘1’, ‘雏田’], [‘2’, ‘佐助’]]</p></blockquote><p><strong>4. 传入字符串</strong></p><pre><code>var string =  &quot;123&quot; var x = Object.entries(string)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>[[“0”, “1”], [“1”, “2”], [“2”, “3”]]</p></blockquote><p><strong>5. 传入数字，浮点数</strong></p><pre><code>var number =  123 var number1 =  123.3 var x = Object.entries(number)var y = Object.entries(number1)</code></pre><p><strong>x y输出结果:</strong></p><blockquote><p>都为 [ ]</p></blockquote><h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p><strong>检测数值元素的每个元素是都否都符合条件</strong></p><pre><code>var number = [2, 34, 45, 1]var x = number.every((i) =&gt;    i &gt; 30)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>false</p></blockquote><h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p><strong>检测数组元素中是否有元素符合指定条件</strong><br><strong>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测</strong><br><strong>如果没有满足条件的元素，则返回false</strong></p><pre><code>var number = [2, 34, 45, 1]var x = number.some((i) =&gt;    i &gt; 30)console.log(x)</code></pre><p><strong>x 输出结果</strong></p><blockquote><p>true</p></blockquote><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><strong>检测数值元素，并返回符合条件所有元素的数组</strong></p><pre><code>var number = [2, 34, 45, 1]var x = number.filter((i) =&gt;    i &gt; 30)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>[34, 45]</p></blockquote><h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p><strong>返回符合传入测试（函数）条件的数组元素</strong><br><strong>获取数组中年龄大于 30 的第一个元素</strong></p><pre><code>var number = [2, 34, 45, 1]var x = number.find((i) =&gt;    i &gt; 30)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>34</p></blockquote><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p><strong>返回符合传入测试（函数）条件的数组元素索引</strong><br>获取数组中年龄大于等于 30 的第一个元素索引位置</p><pre><code>var number = [2, 34, 45, 1]var x = number.findIndex((i) =&gt;    i &gt; 30)</code></pre><p><strong>x 输出结果:</strong></p><blockquote><p>1</p></blockquote><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p><strong>遍历数组中的每一位</strong></p><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];var a = &quot;&quot;;var b = 0;arr.forEach((value, index, array) =&gt; &#123;  console.log(value)  console.log(index)  console.log(array)  console.log(array[index])  a += (array[index])  b += index    &#125;)console.log(a)console.log(b)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>a b c d e f<br>0 1 2 3 4 5<br>[“a”, “b”, “c”, “d”, “e”, “f”] * 6<br>a b c d e f<br>abcdef<br>15</p></blockquote><p><font size=5>forEach() 的 continue 与 break</font></p><p><strong>forEach() 本身是不支持的 <code>continue</code> 与 <code>break</code> 语句的，我们可以通过 <code>some</code> 和 <code>every</code> 来实现</strong><br><strong>continue 实现</strong><br><strong>使用 return 语句实现 continue 关键字的效果：</strong></p><pre><code>var arr = [1, 2, 3, 4, 5];arr.forEach(function (item) &#123;    console.log(item)    if (item === 3) &#123;        return;       //3的元素跳过    &#125;    console.log(item);&#125;);</code></pre><p><strong>输出结果:</strong></p><blockquote><p>1 2 3 4 5<br>1 2 4 5</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5];arr.some(function (item) &#123;    if (item === 2) &#123;        return;     // 不能为 return false    &#125;    console.log(item);&#125;);</code></pre><p><strong>输出结果:</strong></p><blockquote><p>1 3 4 5</p></blockquote><p><strong>break 实现</strong> </p><pre><code>var arr = [1, 2, 3, 4, 5];arr.every(function (item) &#123;        console.log(item);        return item !== 3;        console.log(&quot;我被终止了&quot;)&#125;);</code></pre><p><strong>输出结果:</strong></p><blockquote><p>1 2 3<br>不执行</p></blockquote><h4 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h4><p><strong><code>语法 : Array.from(object, mapFunction, thisValue)</code></strong><br><code>object : 必需，要转换为数组的对象</code><br><code>mapFunction : 可选，数组中每个元素要调用的函数</code><br><code>thisValue : 可选，映射函数(mapFunction)中的 this 对象</code><br><strong>通过给定的对象中创建一个数组</strong></p><pre><code>var arr = Array.from(&quot;RUNOOB&quot;)console.log(arr)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[“R”, “U”, “N”, “O”, “O”, “B”]<br><strong>下面的实例返回集合中包含的对象数组</strong></p></blockquote><pre><code>var setObj = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);var objArr = Array.from(setObj);console.log(objArr[1] == &quot;b&quot;)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>true<br><strong>下面的实例演示如何使用箭头语法和映射函数更改元素的值</strong></p></blockquote><pre><code>var arr = Array.from([1, 2, 3], x =&gt; x * 10);console.log(arr[0]) console.log(arr[1]) console.log(arr[2]) </code></pre><p><strong>输出结果:</strong></p><blockquote><p>10<br>20<br>30</p></blockquote><h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p><strong>判断一个数组是否包含一个指定的值</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;pear&quot;]fruits.includes(&quot;Banana&quot;) fruits.includes(&quot;哈粒嘎&quot;)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>true<br>false</p></blockquote><h4 id="isArray"><a href="#isArray" class="headerlink" title="isArray()"></a>isArray()</h4><p><strong>判断对象是否为数组：</strong></p><pre><code>var obj = &#123;id:&quot;Banana&quot;&#125;var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;pear&quot;]console.log(Array.isArray(fruits))console.log(Array.isArray(obj)) </code></pre><p><strong>输出结果:</strong></p><blockquote><p>true<br>false</p></blockquote><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p><strong>将数组转换为字符串拼接数组</strong><br><strong>里面的参数必须时字符串类型 —–&gt;返回字符串类型</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var fruits1 = fruits.join();var fruits2 = fruits.join(&quot;~&quot;);console.log(fruits1)console.log(fruits2)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>Banana,Orange,Apple,Mango<br>Banana<del>Orange</del>Apple~Mango</p></blockquote><h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><p><strong>返回一个数组索引的迭代器</strong></p><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;,&quot;c&quot;];   //传入对象var obj = &#123;a:123,b:345&#125;     //传入数组var str = &#39;ab1234&#39;;         //传入字符串console.log(Object.keys(obj))console.log(Object.keys(arr))console.log(Object.keys(str))</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[“a”, “b”]<br>[“0”, “1”, “2”]<br>[“0”, “1”, “2”, “3”, “4”, “5”]</p></blockquote><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p><strong>搜索数组中的元素，并返回它所在的位置</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var fruits1=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;];var a = fruits.indexOf(&quot;Apple&quot;);var b = fruits1.indexOf(&quot;Apple&quot;);console.log(a)console.log(b)</code></pre><p><strong>输出 a b 结果:</strong></p><blockquote><p>2<br>2</p></blockquote><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p><strong>搜索数组中的元素，并返回它最后出现的位置</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var fruits1=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;);var b = fruits1.lastIndexOf(&quot;Apple&quot;);console.log(a)console.log(b)</code></pre><p><strong>输出 a b 结果:</strong></p><blockquote><p>2<br>6</p></blockquote><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><strong>对数组的每个元素调用定义的回调函数并返回包含结果的数组</strong><br><strong><code>语法 : array.map(function(currentValue,index,arr), thisValue)</code></strong><br><code>currentValue : 必须。当前元素的值</code><br><code>index : 可选。当前元素的索引值</code><br><code>arr : 可选。当前元素属于的数组对象</code><br><code>thisValue : 可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值。如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。</code></p><pre><code>var arr = [1, 3, 4, 6];//Es5写法let num = arr.map(function (value, index, array) &#123;    console.log(value)    console.log(index)    console.log(array)    return value * 3;&#125;)console.log(num)//ES6箭头函数写法let newNum = arr.map((value, index, array) =&gt; value * 3)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>1 3 4 6<br>0 1 2 3<br>[1, 3, 4, 6]*4<br>[3, 9, 12, 18]</p></blockquote><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p><strong>选取数组的一部分，并返回一个新数组</strong><br><strong><code>array.slice(start, end)</code></strong><br><code>start(从该位开始截取) : 可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）</code><br><code>end(截取该位结束) : 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）</code><br><strong>1个参数时：从该位截取，一直截取到最后</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var citrus = fruits.slice(2);var citrus1 = fruits.slice(1,3)console.log(fruits)console.log(citrus)console.log(citrus1)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[“Banana”, “Orange”, “Lemon”, “Apple”, “Mango”]<br>[“Lemon”, “Apple”, “Mango”]<br> [“Orange”, “Lemon”]</p></blockquote><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p><strong>将数组元素计算为一个值（从左到右）</strong><br><strong><code>语法: array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></strong><br><code>total : 必需。初始值, 或者计算结束后的返回值</code><br><code>currentValue : 必需。当前元素</code><br><code>currentIndex : 可选。当前元素的索引</code><br><code>arr : 可选。当前元素所属的数组对象</code><br><code>initialValue : 可选。传递给函数的初始值</code></p><pre><code>var arr = [1, 3, 5, 7, 9];var x = arr.reduce(function (x, y) &#123;    return x + y;&#125;);var y = arr.reduce(function (x, y) &#123;    return x * 10 + y;&#125;);console.log(arr)console.log(x)console.log(y)</code></pre><p><strong>执行结果</strong></p><blockquote><p>[1, 3, 5, 7, 9]<br>25<br>13579</p></blockquote><h4 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h4><p><strong>将数组元素计算为一个值（从右到左）</strong></p><pre><code>var arr = [1, 3, 5, 7, 9];var x = arr.reduceRight(function (x, y) &#123;    return x + y;&#125;);var y = arr.reduceRight(function (x, y) &#123;    return x * 10 + y;&#125;); console.log(arr)console.log(x)console.log(y)</code></pre><p><strong>执行结果 :</strong></p><blockquote><p>[1, 3, 5, 7, 9]<br>25<br>97531</p></blockquote><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p><strong>返回数组对象的原始值</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];var x=fruits.valueOf();console.log(x)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[“Banana”, “Orange”, “Apple”, “Mango”]     fruits.valueOf()与 fruits返回值一样</p></blockquote><h3 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h3><h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p><strong><code>语法: array.copyWithin(target, start, end)</code></strong><br><code>target : 必需。复制到指定目标索引位置</code><br><code>start : 可选。元素复制的起始位置</code><br><code>end : 可选。停止复制的索引位置 (默认为 array.length)。如果为负值，表示倒数</code><br><strong>从数组的指定位置拷贝元素到数组的另一个指定位置中</strong><br><strong>复制数组的前面两个元素到后面两个元素上</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;pear&quot;]fruits.copyWithin(2, 0)</code></pre><p><strong>fruits 输出结果:</strong></p><blockquote><p>[“Banana”, “Orange”, “Banana”, “Orange”, “Apple”]</p></blockquote><p><strong>复制数组的前面两个元素到第三和第四个位置上：</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;Kiwi&quot;, &quot;Papaya&quot;];fruits.copyWithin(2, 0, 2);</code></pre><p><strong>fruits 输出结果:</strong></p><blockquote><p>[“Banana”,”Orange”,”Banana”,”Orange”,”Kiwi”,”Papaya”]</p></blockquote><h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p><strong><code>语法 : array.fill(value, start, end)</code></strong><br><code>value : 必需。填充的值</code><br><code>start : 可选。开始填充位置</code><br><code>end : 可选。停止填充位置 (默认为 array.length)</code><br><strong>使用一个固定值来填充数组</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;pear&quot;];fruits.fill(&quot;cantaloupe&quot;);</code></pre><p><strong>fruits 输出结果:</strong></p><blockquote><p>[“cantaloupe”, “cantaloupe”, “cantaloupe”, “cantaloupe”, “cantaloupe”]</p></blockquote><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;pear&quot;];fruits.fill(&quot;cantaloupe&quot;, 2, 4);</code></pre><p><strong>fruits 输出结果:</strong></p><blockquote><p>[“Banana”, “Orange”, “cantaloupe”, “cantaloupe”, “pear”]</p></blockquote><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p><strong>删除数组的最后一个元素并返回删除的元素</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.pop())console.log(fruits)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>Mango<br> [“Banana”, “Orange”, “Apple”]</p></blockquote><h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p><strong>删除数组的第一个元素并返回删除的元素</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.shift()console.log(fruits)</code></pre><p><strong>输出结果:</strong></p><blockquote><p> [“Orange”, “Apple”, “Mango”]</p></blockquote><h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p><strong>向数组的末尾添加一个或更多元素，并返回新的长度</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.push(&quot;Kiwi&quot;)console.log(fruits)fruits.push(&quot;Lemon&quot;,&quot;Pineapple&quot;)console.log(fruits)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[“Banana”, “Orange”, “Apple”, “Mango”, “Kiwi”]<br>[“Banana”, “Orange”, “Apple”, “Mango”, “Kiwi”, “Lemon”, “Pineapple”]</p></blockquote><h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p><strong>向数组的开头添加一个或更多元素，并返回新的长度</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.unshift(&quot;Kiwi&quot;)console.log(fruits)fruits.unshift(&quot;Lemon&quot;,&quot;Pineapple&quot;)console.log(fruits)</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[“Kiwi”, “Banana”, “Orange”, “Apple”, “Mango”]<br>[“Lemon”, “Pineapple”, “Kiwi”, “Banana”, “Orange”, “Apple”, “Mango”]</p></blockquote><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p><strong>反转数组的元素顺序</strong></p><pre><code>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];fruits.reverse();console.log(fruits)</code></pre><p><strong>输出结果:</strong></p><blockquote><p> [“Mango”, “Apple”, “Orange”, “Banana”]</p></blockquote><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p><strong>对数组的元素进行排序</strong><br><strong>排序的方法比较的是 ASCLL，如果正常排序，此时 sort( ) 里面需要写一个匿名函数</strong></p><pre><code>arr.sort( function ( a, b )&#123;    return;    &#125;);</code></pre><p><strong>匿名函数注意事项:</strong></p><ol><li>必须写 2 形参</li><li>看返回值： 当返回值为<code>负数</code>时，那么前面的数放在前面, 当返回值为<code>正数</code>时，那么后面的数在前,为 <code>0 </code>时,不动</li></ol><pre><code>var arr = [1, 3, 2, 5, -1];arr.sort();console.log(arr)var arr1 = [1, 3, 5, 4, 10];arr1.sort(); //这里比较的是ASCLLconsole.log(arr1)arr1.sort(function (a, b) &#123;    if (a &gt; b) &#123;        return 1;    &#125; else &#123;        return -1;    &#125;&#125;);console.log(arr1);</code></pre><p><strong>输出结果:</strong></p><blockquote><p>[-1, 1, 2, 3, 5]<br>[1, 10, 3, 4, 5]<br>[1, 3, 4, 5, 10]</p></blockquote><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p><strong>从数组中添加或删除元素</strong><br><strong><code>语法: array.splice(index,howmany,item1,.....,itemX)</code></strong><br><code>index : 从第几位开始</code><br><code>howmany : 截取多少长度</code><br><code>item1,.....,itemX : 在切口处添加新的数据</code></p><pre><code>var arr = [1, 2, 3, 4, 5]arr.splice(1, 2)console.log(arr)var arr1 = [1, 2, 3, 7, 8]arr1.splice(3, 0, 4, 5, 6)console.log(arr1)</code></pre><p><strong>输出结果 :</strong></p><blockquote><p>[1, 4, 5]<br>[1, 2, 3, 4, 5, 6, 7, 8]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局</title>
      <link href="/2020/11149461.html"/>
      <url>/2020/11149461.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>响应式布局是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本，这个概念就是为解决移动互联网而诞生的</p><h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><p>通过css中的media query(媒介查询)@media功能来判断终端宽度在多少像素内，从而执行对应的css样式。<br><strong>优点</strong><br>面对不同分辨率设备灵活性强<br>能够解决设备显示适应问题<br><strong>缺点</strong><br>兼容各种设备工作量大，效率低下<br>代码累赘，会出现隐藏无用的元素，加载时间加长<br>其实这是一种折衷性质的设计解决方案，多方面因素影响而达不到最佳效果<br>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况.域名查询 网站注册</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;    &lt;title&gt;响应式布局&lt;/title&gt;    &lt;style type=&quot;text/css&quot;&gt;        body,        html &#123;            margin: 0;            padding: 0;        &#125;        .box &#123;            height: 100px;            color: #000;            font-size: 16px;            text-align: center;            line-height: 100px;            float: left;        &#125;        .box1 &#123;            background: red;        &#125;        .box2 &#123;            background: orange;        &#125;        .box3 &#123;            background: yellow;        &#125;        .box4 &#123;            background: green;        &#125;        @media(min-width: 768px) &#123;            .box1 &#123;                width: 20%;            &#125;            .box2 &#123;                width: 60%;            &#125;            .box3 &#123;                width: 20%;            &#125;            .box4 &#123;                width: 100%;            &#125;        &#125;        @media (min-width: 372px) and (max-width: 768px) &#123;            .box1 &#123;                width: 50%;            &#125;            .box2 &#123;                width: 50%;            &#125;            .box3 &#123;                width: 50%;            &#125;            .box4 &#123;                width: 50%;            &#125;        &#125;        @media (max-width: 372px) &#123;            .box1 &#123;                width: 100%;            &#125;            .box2 &#123;                width: 100%;            &#125;            .box3 &#123;                width: 100%;            &#125;            .box4 &#123;                width: 100%;            &#125;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;wrapper&quot;&gt;        &lt;div class=&quot;box box1&quot;&gt;box1&lt;/div&gt;        &lt;div class=&quot;box box2&quot;&gt;box2&lt;/div&gt;        &lt;div class=&quot;box box3&quot;&gt;box3&lt;/div&gt;        &lt;div class=&quot;box box4&quot;&gt;box4&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React redux的使用</title>
      <link href="/2020/110857455.html"/>
      <url>/2020/110857455.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redux 是 JavaScript 状态容器，提供可预测化得状态管理，可以跨组件、跨页面推送数据。应用场景如 : 购物车、会员登录等功能模块。Redux 由 Flux 演变而来<br><strong>存储流程:</strong><br>Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中，store 是简单的 JavaScript 对象，而改变应用的 start 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers来修改 state。整个 state 转化是在 reducers 中完成  </p><p><strong>流程可分为4大部:</strong><br><strong>1. 选购商品</strong><br><strong>2. 商品装车</strong><br><strong>3. 存入仓库</strong><br><strong>4. 从仓库获取商品</strong></p><h2 id="安装-redux"><a href="#安装-redux" class="headerlink" title="安装 redux"></a>安装 redux</h2><pre><code>npm install redux --savenpm install react-redux --save</code></pre><p><font size=5>计数器案例:</font></p><p>在 src 新建一个 store 文件, 再次文件下分别建立 actions reducers 文件<br>子组件 :</p><pre><code>import React from &#39;react&#39;;class Couter extends React.Component &#123;    render() &#123;        return(            &lt;React.Fragment&gt;                &lt;div&gt;                    子组件计数器 : 0                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default Couter;</code></pre><h2 id="选购商品"><a href="#选购商品" class="headerlink" title="选购商品"></a>选购商品</h2><pre><code>import React from &#39;react&#39;// 关联仓库，将组件进行包裹起来，此时该组件就有 redux 的属性import &#123;connect&#125; from &#39;react-redux&#39;import Conter from &quot;../../components/counter&quot;import actions from &#39;../../store/actions&#39;;class IndexPage extends React.Component &#123;    constructor() &#123;        super();        this.num = 0     &#125;    inCount() &#123;     //  点击 ++        // 1. 选购商品 this.props.dispatch        //  使用 dispatch 属性触发 actions，  其中 type 为必填项,其他的属性可以自行添加         //  this.props.dispatch(&#123;type: &quot;INC&quot;, data: &#123;count: ++this.num&#125;&#125;)   //正常写法,推荐使用下面采取模块化        // 调用 actions.counter.incCount 方法 并传递数据        this.props.dispatch(actions.counter.incCount(&#123;count: ++this.num&#125;))    &#125;    deCount() &#123;      //点击 --         this.props.dispatch(actions.counter.decCount(&#123;count: --this.num&#125;))    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &#123;/* 子组件 */&#125;                &lt;Conter /&gt;                &lt;div&gt;                     计数器 : &lt;button type=&quot;button&quot; onClick=&#123;this.deCount.bind(this)&#125;&gt;-&lt;/button&gt; 0 &lt;button onClick=&#123;this.inCount.bind(this)&#125;&gt;+&lt;/button&gt;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default connect()(IndexPage);</code></pre><p><strong>actions 文件下建立 index.js  和 counter.js</strong><br><strong>counter.js文件</strong></p><pre><code>export function incCount(data) &#123;    return &#123;        type: &quot;INC&quot;,        data   // data:data    &#125;&#125;export function decCount(data) &#123;    return &#123;        type: &quot;DEC&quot;,        data    &#125;&#125;</code></pre><p><strong>index.js文件</strong></p><pre><code>// import &#123;decCount, decCount&#125; from &#39;./couter&#39; 导入 decCount decCount方法import * as counter from &#39;./counter&#39;    //导入 counter文件中所有的方法export default &#123;    counter,    //counter: counter&#125;</code></pre><h2 id="商品装车"><a href="#商品装车" class="headerlink" title="商品装车"></a>商品装车</h2><p><strong>reducers 文件下建立 counter.js</strong><br><strong>counter.js文件</strong></p><pre><code>//2. 商品装车let defaultState = &#123;   count: 0&#125;// state : 数据源       action : 获取 dispatch 的值function counterReducer(state = defaultState, action) &#123;  switch (action.type) &#123;    case &quot;INC&quot;:      return &#123; ...state, ...action.data &#125;;              //写法一  常用    case &quot;DEC&quot;:      return Object.assign(&#123;&#125;, state, action.data)      //写法二    default:      return state;    //必须的返回 state， 否则会出错  &#125;&#125;export default counterReducer;</code></pre><h2 id="存入仓库"><a href="#存入仓库" class="headerlink" title="存入仓库"></a>存入仓库</h2><p><strong>reducers 文件下建立 index.js</strong><br><strong>index.js文件</strong></p><pre><code>// 引入 createStore 仓库，为 store 的创建做准备  combineReducers用于组合关联使用import &#123; createStore, combineReducers &#125; from &#39;redux&#39;;import CounterReducer from &#39;./counter&#39;;// 3.创建仓库， 将reducers存储到仓库(存放数据)// let store = createStore(CounterReducer)   传入单个方法let store = createStore(combineReducers(&#123;   //传入多个个方法    counter: CounterReducer,  &#125;))  export default store;</code></pre><p><strong>在入口index中添加 store</strong></p><pre><code>import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import RouterComponent from &#39;./router&#39;;// 用于读取数据 import &#123; Provider &#125; from &#39;react-redux&#39;import store from &#39;./store/reducers&#39;import * as serviceWorker from &#39;./serviceWorker&#39;;function App() &#123;  return (    &lt;React.Fragment&gt;      &#123;/* 使用 Provider, 添加上 store 属性*/&#125;      &lt;Provider store=&#123;store&#125;&gt;        &lt;RouterComponent /&gt;      &lt;/Provider&gt;    &lt;/React.Fragment&gt;  )&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: https://bit.ly/CRA-PWAserviceWorker.unregister();</code></pre><h2 id="从仓库获取商品"><a href="#从仓库获取商品" class="headerlink" title="从仓库获取商品"></a>从仓库获取商品</h2><pre><code>import React from &#39;react&#39;// 关联仓库，将组件进行包裹起来，此时该组件就有 redux 的属性import &#123;connect&#125; from &#39;react-redux&#39;import Conter from &quot;../../components/counter&quot;import actions from &#39;../../store/actions&#39;;class IndexPage extends React.Component &#123;    constructor() &#123;        super();        this.num = 0     &#125;    inCount() &#123;     //  点击 ++        this.props.dispatch(actions.counter.incCount(&#123;count: ++this.num&#125;))    &#125;    deCount() &#123;      //点击 --         this.props.dispatch(actions.counter.decCount(&#123;count: --this.num&#125;))    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &#123;/* 子组件 */&#125;                &lt;Conter /&gt;                &lt;div&gt;                     &#123;/* 4. 从仓库获取商品 */&#125;                    计数器 : &lt;button type=&quot;button&quot; onClick=&#123;this.deCount.bind(this)&#125;&gt;-&lt;/button&gt;  &#123;this.props.state.counter.count&#125; &lt;button onClick=&#123;this.inCount.bind(this)&#125;&gt;+&lt;/button&gt;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default connect((state) =&gt;&#123;  //  state 接收第二步中的 state    return &#123;        state : state    &#125;&#125;)(IndexPage);</code></pre><p>子组件 :</p><pre><code>import React from &#39;react&#39;;import &#123;connect&#125; from &#39;react-redux&#39;class Couter extends React.Component &#123;    render() &#123;        const &#123;count&#125; = this.props        return(            &lt;React.Fragment&gt;                &lt;div&gt;                    子组件计数器 : &#123;count&#125;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;//只有和仓关联起来，才可访问 redux 的属性export default connect((state) =&gt;(&#123;    count:state.counter.count&#125;))(Couter);</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React路由的基本使用</title>
      <link href="/2020/110142024.html"/>
      <url>/2020/110142024.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在最新React中，使用的是<strong>react-router-dom</strong></p><h3 id="安装路由"><a href="#安装路由" class="headerlink" title="安装路由"></a>安装路由</h3><pre><code>npm install --save-dev react-router-dom</code></pre><h3 id="路由的基础配置"><a href="#路由的基础配置" class="headerlink" title="路由的基础配置"></a>路由的基础配置</h3><p><strong>第一步:</strong><br>将 <code>App.js</code> 更改成 <code>router.js</code>, 内容如下 :</p><pre><code>/*router.js 页面里的代码HashRouter: 有#号BrowserRouter: 没有#号Route: 设置路由与组件关联Switch: 只要匹配到一个地址不往下匹配，相当于for循环里面的breakLink: 跳转页面，相当于vue里面的router-linkexact: 完全匹配路由Redirect: 路由重定向*/import React from &#39;react&#39;;import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;//如若更换成 hash 路由模式需要将  BrowserRouter 更换为 HashRouterclass RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Route&gt;&lt;/Route&gt;            &lt;/Switch&gt;                      &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><p><strong>第二步:</strong><br>将入口文件<code>index.js</code>内容更改如下:</p><pre><code>import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import RouterComponent from &#39;./router&#39;;import * as serviceWorker from &#39;./serviceWorker&#39;;function App() &#123;  return (    &lt;React.Fragment&gt;      &lt;RouterComponent /&gt;    &lt;/React.Fragment&gt;  )&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));// If you want your app to work offline and load faster, you can change// unregister() to register() below. Note this comes with some pitfalls.// Learn more about service workers: https://bit.ly/CRA-PWAserviceWorker.unregister();</code></pre><p><strong>完成以上操作基础配置完成</strong></p><h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p><strong>在 pages 文件夹下新建 3 页面 :</strong><br><img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/a28b18e5b30b624193e834105772ac0.png"></p><pre><code>// Index文件夹下的index.jsimport React from &#39;react&#39;;import &#123; Link &#125; from &#39;react-router-dom&#39;;class IndexPage extends React.Component &#123;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;div&gt;首页&lt;/div&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;Link to=&quot;/news&quot;&gt;前往新闻页面&lt;/Link&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default IndexPage</code></pre><pre><code>// New文件夹下index.jsimport React from &#39;react&#39;;import &#123; Link &#125; from &#39;react-router-dom&#39;;class News extends React.Component &#123;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;div&gt;我是新闻页面&lt;/div&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;Link to=&quot;/news/details&quot;&gt;新闻详情1&lt;/Link&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default News;</code></pre><pre><code>// New文件夹下details.jsimport React from &#39;react&#39;;class NewsDetails extends React.Component &#123;    render() &#123;        return (                      &lt;React.Fragment&gt;                 &lt;div&gt;新闻详情1页面&lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default NewsDetails;</code></pre><p><strong><code>router</code> 配置文件 <code>router.js</code>代码如下:</strong></p><pre><code>import React from &#39;react&#39;;import &#123;BrowserRouter as Router, Route,Switch&#125; from &#39;react-router-dom&#39;;import IndexPage from &quot;./pages/Index&quot;;import NewsPage from &#39;./pages/News&#39;;import NewsDetails from &#39;./pages/News/details&#39;class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><p><strong>此时已经可以完成简单的路由跳转:</strong><br><img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/5ab8e180349328960ed54a43ff67140.png"></p><h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="方法一-params"><a href="#方法一-params" class="headerlink" title="方法一 : params"></a>方法一 : params</h4><p><strong>通过<code>params</code>接受到传递过来的参数</strong><br><strong>路由表中 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;import IndexPage from &quot;./pages/Index&quot;;import NewsPage from &#39;./pages/News&#39;;import NewsDetails from &#39;./pages/News/details&#39;class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;              &lt;!-- 这里 id title 为需要接收的参数 --&gt;              &lt;Route path=&quot;/news/details/:id/:title&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><p><strong>Link处 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123; Link &#125; from &#39;react-router-dom&#39;;class News extends React.Component &#123;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;div&gt;我是新闻页面&lt;/div&gt;                &lt;ul&gt;                     &lt;!-- 1 新闻详情1为传递的参数 --&gt;                    &lt;li&gt;&lt;Link to=&quot;/news/details/1/新闻详情1&quot;&gt;新闻详情1&lt;/Link&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default News;</code></pre><p><strong>sort页面 :</strong></p><pre><code>import React from &#39;react&#39;;class NewsDetails extends React.Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;&#125;;        console.log(&quot;id:&quot; + props.match.params.id,)    &#125;    //使用 this.props.match.params 就可以获取到传递过来的参数（ id title ）    componentDidMount() &#123;  // 组件生命钩子函数，组件已经加载完成        console.log(&quot;title:&quot; + this.props.match.params.title)    &#125;    render() &#123;        return (            &lt;div&gt;新闻详情1页面&lt;/div&gt;        )    &#125;&#125;export default NewsDetails;</code></pre><h4 id="方法二-query"><a href="#方法二-query" class="headerlink" title="方法二 : query"></a>方法二 : query</h4><p><strong>通过<code>query</code>接受到传递过来的参数</strong><br><strong>前提：</strong>不能刷新页面,必须由其他页面跳过来，参数才会被传递过来<br><strong>注：</strong>不需要配置路由表。路由表中的内容照常<br><strong>路由表中 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123;BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;import IndexPage from &quot;./pages/Index&quot;;import NewsPage from &#39;./pages/News&#39;;import NewsDetails from &#39;./pages/News/details&#39;class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;              &#123;/* 不需要配置路由表,路由表中的内容照常 */&#125;              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><p><strong>Link处 :</strong></p><pre><code>import React from &#39;react&#39;;class News extends React.Component &#123;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;div&gt;我是新闻页面&lt;/div&gt;                &lt;ul&gt;                    &lt;li onClick=&#123;() =&gt; &#123;                        this.props.history.push(&#123;                            pathname: &quot;/news/details&quot;,                            search:&quot;?id=1&amp;title=新闻详情1&quot;,                            query: &#123;                                id: 1,                                title: &quot;新闻详情1&quot;                            &#125;                        &#125;)                    &#125;&#125;&gt;新闻详情1&lt;/li&gt;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default News;</code></pre><p><strong>sort页面 :</strong></p><pre><code>import React from &#39;react&#39;;class NewsDetails extends React.Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;&#125;;    &#125;    componentDidMount() &#123;  // 组件生命钩子函数，组件已经加载完成        // 使用 this.props.location.query  就可以获取到传递过来的参数（ id title ）        console.log(this.props.location.query.id )        console.log(this.props.location.query.title )    &#125;    render() &#123;        return (        &lt;div&gt;新闻详情1页面,id:&#123;this.props.location.query.id &#125;&lt;/div&gt;        )    &#125;&#125;export default NewsDetails;</code></pre><h4 id="方法三-自定义函数"><a href="#方法三-自定义函数" class="headerlink" title="方法三 : 自定义函数"></a>方法三 : 自定义函数</h4><p><strong>通过自定义函数接受到传递过来的参数</strong><br><strong>在 utils 文件夹下建立一个 js 文件，内容如下 :</strong></p><pre><code>export function localParam (search, hash) &#123;    search = search || window.location.search;    hash = hash || window.location.hash;    var fn = function(str, reg) &#123;        if (str) &#123;            var data = &#123;&#125;;            str.replace(reg, function($0, $1, $2, $3) &#123;                data[$1] = $3;            &#125;);            return data;        &#125;    &#125;;    return &#123;            search : fn(search, new RegExp(&quot;([^?=&amp;]+)(=([^&amp;]*))?&quot;, &quot;g&quot;)) || &#123;&#125;,            hash : fn(hash, new RegExp(&quot;([^#=&amp;]+)(=([^&amp;]*))?&quot;, &quot;g&quot;)) || &#123;&#125;        &#125;;    &#125;</code></pre><p><strong>路由表中 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123;BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;import IndexPage from &quot;./pages/Index&quot;;import NewsPage from &#39;./pages/News&#39;;import NewsDetails from &#39;./pages/News/details&#39;class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;              &#123;/* 不需要配置路由表,路由表中的内容照常 */&#125;              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><p><strong>Link处 :</strong></p><pre><code>import React from &#39;react&#39;;class News extends React.Component &#123;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;div&gt;我是新闻页面&lt;/div&gt;                &lt;ul&gt;                    &lt;li onClick=&#123;() =&gt; &#123;                        this.props.history.push(&quot;/news/details?id=1&amp;title=新闻详情1&quot;)                    &#125;&#125;&gt;新闻详情1&lt;/li&gt;                &lt;/ul&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default News;</code></pre><p><strong>sort页面 :</strong></p><pre><code>import React from &#39;react&#39;;// 引入自定义方法import &#123; localParam &#125; from &#39;../../utils&#39;class NewsDetails extends React.Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;&#125;;    &#125;    componentDidMount() &#123;  // 组件生命钩子函数，组件已经加载完成        console.log(&quot;id ：&quot; + localParam(this.props.location.search).search.id);        // 如是中文，则会出现乱码        console.log(&quot;title ：&quot; + localParam(this.props.location.search).search.title)         // 如果想转回中文使用 decodeURIComponent 解码        console.log(&quot;title&quot; + decodeURIComponent(localParam(this.props.location.search).search.title));    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;div&gt;新闻详情1页面&lt;/div&gt;                &lt;ul&gt;                    &lt;li&gt;&#123;localParam(this.props.location.search).search.id&#125;&lt;/li&gt;                    &lt;li&gt;&#123;decodeURIComponent(localParam(this.props.location.search).search.title)&#125;&lt;/li&gt;                &lt;/ul&gt;                &#123;/* （-1）返回上一级路由 */&#125;                &lt;button type=&#123;&quot;button&quot;&#125; onClick=&#123;() =&gt; &#123; this.props.history.go(-1) &#125;&#125;&gt;返回&lt;/button&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default NewsDetails;</code></pre><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><h4 id="方法一-自定义组件"><a href="#方法一-自定义组件" class="headerlink" title="方法一 : 自定义组件"></a>方法一 : 自定义组件</h4><p><strong>制作异步函数组件</strong><br><strong>建立AsynComponent.js文件，内容如下：</strong></p><pre><code>import React, &#123; Component &#125; from &quot;react&quot;;export default function asyncComponent(importComponent) &#123;    class AsyncComponent extends Component &#123;        constructor(props) &#123;            super(props);            this.state = &#123;                component: null            &#125;;        &#125;        async componentDidMount() &#123;            const &#123; default: component &#125; = await importComponent();            this.setState(&#123;                component: component            &#125;);        &#125;        render() &#123;            const C = this.state.component;            return C ? &lt;C &#123;...this.props&#125; /&gt; : null;        &#125;    &#125;    return AsyncComponent;&#125;</code></pre><p><strong>路由表中 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123;BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;import asyncComponent from &#39;./assets/components/async/asyncComponent&#39;;  // 引入懒加载组件// 激活chunkFilename,默认不激活(路由懒加载)const  IndexPage = asyncComponent(() =&gt;import(&quot;./pages/Index&quot;));const  NewsPage = asyncComponent(() =&gt;import(&quot;./pages/News&quot;));const  NewsDetails = asyncComponent(() =&gt;import(&quot;./pages/News/details&quot;));class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><h4 id="方法二-lazy和suspense"><a href="#方法二-lazy和suspense" class="headerlink" title="方法二 : lazy和suspense"></a>方法二 : lazy和suspense</h4><p><strong>路由表中 :</strong></p><pre><code>import React, &#123; lazy, Suspense &#125; from &#39;react&#39;;      //导入 lazy, Suspense import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;const IndexPage = lazy(() =&gt; import(&quot;./pages/Index&quot;));const NewsPage = lazy(() =&gt; import(&quot;./pages/News&quot;));const NewsDetails = lazy(() =&gt; import(&quot;./pages/News/details&quot;));class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &#123;/* 用 Suspense 包裹 Route */&#125;              &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;                &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;                &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;                &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;              &lt;/Suspense&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><h4 id="路由嵌套-主子路由"><a href="#路由嵌套-主子路由" class="headerlink" title="路由嵌套(主子路由)"></a>路由嵌套(主子路由)</h4><p><strong>路由表中 :</strong></p><pre><code>import React, &#123; lazy, Suspense &#125; from &#39;react&#39;;import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;const IndexPage = lazy(() =&gt; import(&quot;./pages/Index&quot;));const GoodssPage = lazy(() =&gt; import(&quot;./pages/Home&quot;));class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;                &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;                &#123;/* 这里不需要添加 exact */&#125;                &lt;Route path=&quot;/goods&quot; component=&#123;GoodssPage&#125;&gt;&lt;/Route&gt;              &lt;/Suspense&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre><p><strong>sort页面 :</strong></p><pre><code>import React, &#123; lazy, Suspense &#125; from &#39;react&#39;;import &#123; Route, Switch, Redirect &#125; from &#39;react-router-dom&#39;;const GoodsItem = lazy(() =&gt; import(&quot;./item&quot;))const GoodsDetails = lazy(() =&gt; import(&quot;./details&quot;))const GoodsEvaluation = lazy(() =&gt; import(&quot;./evaluation&quot;))class Index extends React.Component &#123;    goPage(url) &#123;        // 这里使用 replace 方法，不采用 push        this.props.history.replace(url);    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;ul&gt;                    &lt;li onClick=&#123;this.goPage.bind(this, &#39;/goods/item&#39;)&#125;&gt;商品&lt;/li&gt;                    &lt;li onClick=&#123;this.goPage.bind(this, &#39;/goods/details&#39;)&#125;&gt;详情&lt;/li&gt;                    &lt;li onClick=&#123;this.goPage.bind(this, &#39;/goods/evaluation&#39;)&#125;&gt;评价&lt;/li&gt;                &lt;/ul&gt;                &lt;button type=&quot;button&quot; onClick=&#123;this.props.history.go.bind(this, -1)&#125;&gt;返回&lt;/button&gt;                &lt;div&gt;                    &lt;Switch&gt;                        &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;                            &#123;/* 这里不需要添加 exact */&#125;                            &lt;Route path=&quot;/goods/item&quot; component=&#123;GoodsItem&#125;&gt;&lt;/Route&gt;                            &lt;Route path=&quot;/goods/details&quot; component=&#123;GoodsDetails&#125;&gt;&lt;/Route&gt;                            &lt;Route path=&quot;/goods/evaluation&quot; component=&#123;GoodsEvaluation&#125;&gt;&lt;/Route&gt;                            &#123;/* 路由重定向 : 需要要放在最下面 ，先有 path*/&#125;                            &lt;Redirect to=&quot;/goods/item&quot;&gt;&lt;/Redirect&gt;                        &lt;/Suspense&gt;                    &lt;/Switch&gt;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default Index;</code></pre><h4 id="子组件路由跳转"><a href="#子组件路由跳转" class="headerlink" title="子组件路由跳转"></a>子组件路由跳转</h4><p><strong>withRouter实现子组件路由跳转</strong><br><strong>sort页面 :</strong></p><pre><code>import React, &#123; lazy, Suspense &#125; from &#39;react&#39;;import &#123; Route, Switch, Redirect &#125; from &#39;react-router-dom&#39;;import GoodsNav from &quot;../../assets/components/GoodsNav&quot;      //引入 GoodsNav 组件const GoodsItem = lazy(() =&gt; import(&quot;./item&quot;))const GoodsDetails = lazy(() =&gt; import(&quot;./details&quot;))const GoodsEvaluation = lazy(() =&gt; import(&quot;./evaluation&quot;))class Index extends React.Component &#123;    render() &#123;        return (            &lt;React.Fragment&gt;                &#123;/* GoodsNav子组件 */&#125;                &lt;GoodsNav&gt;&lt;/GoodsNav&gt;                &lt;button type=&quot;button&quot; onClick=&#123;this.props.history.go.bind(this, -1)&#125;&gt;返回&lt;/button&gt;                &lt;div&gt;                    &lt;Switch&gt;                        &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;                            &#123;/* 这里不需要添加 exact */&#125;                            &lt;Route path=&quot;/goods/item&quot; component=&#123;GoodsItem&#125;&gt;&lt;/Route&gt;                            &lt;Route path=&quot;/goods/details&quot; component=&#123;GoodsDetails&#125;&gt;&lt;/Route&gt;                            &lt;Route path=&quot;/goods/evaluation&quot; component=&#123;GoodsEvaluation&#125;&gt;&lt;/Route&gt;                            &#123;/* 路由重定向 : 需要要放在最下面 ，先有 path*/&#125;                            &lt;Redirect to=&quot;/goods/item&quot;&gt;&lt;/Redirect&gt;                        &lt;/Suspense&gt;                    &lt;/Switch&gt;                &lt;/div&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default Index;</code></pre><p><strong>新建一个GoodsNav组件 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123; withRouter &#125; from &#39;react-router-dom&#39;    //引入 withRouterfunction GoodsNav(props) &#123;    const goPage = (url) =&gt; &#123;         console.log(this,props,url)   //这里没有 this : undefined        props.history.replace(url)    &#125;;    return (        &lt;ul&gt;            &lt;li onClick=&#123;goPage.bind(null, &#39;/goods/item&#39;)&#125;&gt;商品&lt;/li&gt;            &lt;li onClick=&#123;goPage.bind(null, &#39;/goods/details&#39;)&#125;&gt;详情&lt;/li&gt;            &lt;li onClick=&#123;goPage.bind(null, &#39;/goods/evaluation&#39;)&#125;&gt;评价&lt;/li&gt;        &lt;/ul&gt;    )&#125;export default withRouter(GoodsNav);</code></pre><h3 id="路由认证"><a href="#路由认证" class="headerlink" title="路由认证"></a>路由认证</h3><p><strong>制作会员认证路由 :</strong></p><pre><code>//在routes/private.js里面的代码import React from &#39;react&#39;;import &#123;Route,Redirect&#125; from &#39;react-router-dom&#39;;export function AuthRoute(&#123; component:Component, ...rest &#125;) &#123;    return (        &lt;Route &#123;...rest&#125; render=&#123;props =&gt;                Boolean(localStorage[&#39;isLogin&#39;]) ? (                    &lt;Component &#123;...props&#125; /&gt;                ) : (                    &lt;Redirect                        to=&#123;&#123;                            pathname: "/login",                            state: &#123; from: props.location &#125;                        &#125;&#125;                    /&gt;                )            &#125;        /&gt;    );&#125;</code></pre><p><strong>建立首页 :</strong></p><pre><code>import React from &#39;react&#39;;import &#123;Link&#125; from &#39;react-router-dom&#39;;class IndexPage extends React.Component&#123;    render() &#123;        return(            &lt;React.Fragment&gt;                &lt;div&gt;首页&lt;/div&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;Link to=&quot;/login&quot;&gt;会员登录&lt;/Link&gt;&lt;/li&gt;                    &lt;li&gt;&lt;Link to=&quot;/user&quot;&gt;会员中心&lt;/Link&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/React.Fragment&gt;                    )    &#125;&#125;export default IndexPage</code></pre><p><strong>建立会员登录 :</strong></p><pre><code>import React from &#39;react&#39;;class Login extends React.Component &#123;    constructor() &#123;        super();        this.state=&#123;            username: &quot;&quot;,            password: &quot;&quot;,        &#125;    &#125;    doLogin() &#123;        if(this.state.username.match(/^\s*$/)) &#123;            alert(&quot;请输入用户名&quot;);            return;        &#125;        if(this.state.password.match(/^\s*$/)) &#123;            alert(&quot;请输入用密码&quot;);            return;        &#125;        // 登录成功将username进行存储，并返回上级        localStorage[&#39;username&#39;] = this.state.username;        localStorage[&#39;isLogin&#39;] = true;        this.props.history.go(-1);    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                     &lt;div&gt;                         用户名 : &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; onClick=&#123;(e)=&gt;&#123;                             this.setState(&#123;username : e.target.value&#125;)                         &#125;&#125;/&gt;                         &lt;br/&gt;                         密码 : &lt;input type=&quot;text&quot; placeholder=&quot;请输入密码&quot; onClick=&#123;(e)=&gt;&#123;                             this.setState(&#123;password: e.target.value&#125;)                         &#125;&#125;/&gt;                     &lt;/div&gt;                     &lt;button type=&quot;button&quot; onClick=&#123;this.doLogin.bind(this)&#125;&gt;登录&lt;/button&gt;            &lt;/React.Fragment&gt;               )    &#125;&#125;export default Login;</code></pre><p><strong>建立会员中心页面 :</strong></p><pre><code>import React from &#39;react&#39;;class User extends React.Component &#123;    outLogin() &#123;        // 退出清空数据        localStorage.clear();        this.props.history.replace(&quot;/login&quot;)    &#125;    render() &#123;        return(            &lt;React.Fragment&gt;            &lt;div&gt;欢迎&#123;localStorage[&#39;username&#39;]&#125; 回来！&lt;/div&gt;            &lt;button type=&quot;button&quot; onClick=&#123;this.outLogin.bind(this)&#125;&gt;安全退出&lt;/button&gt;                 &lt;/React.Fragment&gt;   )    &#125;&#125;export default User;</code></pre><p><strong>路由表中 :</strong></p><pre><code>import React, &#123; lazy, Suspense &#125; from &#39;react&#39;;import &#123; BrowserRouter as Router, Route, Switch &#125; from &#39;react-router-dom&#39;;// 引入路由认证 js import &#123; AuthRoute &#125; from &quot;./utils/router/private&quot;const IndexPage = lazy(() =&gt; import(&quot;./pages/Index&quot;));const LoginPage = lazy(() =&gt; import(&quot;./pages/login&quot;));const UserPage = lazy(() =&gt; import(&quot;./pages/user&quot;));class RouterComponent extends React.Component &#123;  render() &#123;    return (      &lt;React.Fragment&gt;        &lt;Router&gt;          &lt;React.Fragment&gt;            &lt;Switch&gt;              &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;                &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;                &lt;Route path=&quot;/login&quot; exact component=&#123;LoginPage&#125;&gt;&lt;/Route&gt;                &#123;/* 将 Route 更换成 AuthRoute*/&#125;                &lt;AuthRoute path=&quot;/user&quot; exact component=&#123;UserPage&#125;&gt;&lt;/AuthRoute&gt;              &lt;/Suspense&gt;            &lt;/Switch&gt;          &lt;/React.Fragment&gt;        &lt;/Router&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default RouterComponent;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中props与state的区别</title>
      <link href="/2020/102745355.html"/>
      <url>/2020/102745355.html</url>
      
        <content type="html"><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>主要是用于组件之间传递参数，获取组件的属性值。 组件之间数据单向流动 ，从父组件流向子组件。属性值是无法修改的，它是只读的。</p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>React组件的核心，是数据的来源，主要用于组件更新控制。如果想重新渲染或更新组件，只需要修改<code>state</code>即可，然后根据具体修改的<code>state</code>,重新渲染用户界面（无需操作DOM对象），可以通过<code>this.state</code>来访问它们</p><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p>在React中，如果想更新<code>state</code>里面的值，必须使用<code>this.setState( )</code>方法,从而更新组件的状态，这是一个异步方法，而且有第二个参数，是一个回调函数</p><p><strong>代码示例:</strong></p><pre><code>import React from &#39;react&#39;;// 父组件class Father extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;      // 初始化数据      name: &quot;鸣人&quot;    &#125;  &#125;;  componentDidMount() &#123;    //修改 name 值    this.setState(&#123; name: &quot;佐助&quot; &#125;, () =&gt; &#123; //第二个参数：回调函数      //输出 佐助      console.log(this.state.name)    &#125;)    // 输出 鸣人    name值已经修改，但输出的是鸣人，原因是setState是一个异步方法      console.log(this.state.name)  &#125;  render() &#123;    const &#123; name &#125; = this.state    return (      &lt;React.Fragment&gt;        &#123;/* 传递 name 参数 */&#125;        &lt;Son myName=&#123;name&#125;&gt;&lt;/Son&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;// 子组件class Son extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;&#125;  &#125;  render() &#123;    const &#123; myName &#125; = this.props    return (      &lt;React.Fragment&gt;        &#123;/* 通过 this.props获取属性值 */&#125;        &lt;h4&gt;我的名字: &#123;myName&#125;&lt;/h4&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;export default Father;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> props </tag>
            
            <tag> state </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件的生命周期的使用</title>
      <link href="/2020/102645464.html"/>
      <url>/2020/102645464.html</url>
      
        <content type="html"><![CDATA[<h3 id="组件的生命周期钩子函数"><a href="#组件的生命周期钩子函数" class="headerlink" title="组件的生命周期钩子函数"></a>组件的生命周期钩子函数</h3><p>“ 钩子 ”就是在某个阶段给你一个做某些处理的机会。生命周期钩子函数就是在组件预备、创建、使用和销毁的过程中的函数监听。就和我们人一样，从出生到死亡的过程<br><strong>react的生命周期可以分成三个部分：</strong><br><strong>1. 挂载</strong><br><strong>2. 渲染&amp;&amp;更新</strong><br><strong>3. 卸载</strong></p><h3 id="1-挂载"><a href="#1-挂载" class="headerlink" title="1. 挂载"></a>1. 挂载</h3><p>当组件实例被创建并插入 <code>DOM</code> 中时，其生命周期调用顺序如下：</p><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor( )"></a>constructor( )</h5><p>在 <strong>React 组件挂载之前，</strong>会调用此钩子函数。  </p><p><strong>此钩子函数仅用于一下两种情况:</strong></p><ol><li>通过给<code>this.state</code>赋值对象来初始化内部<code>state</code></li><li>为事件处理函数绑定实例  </li></ol><p><strong>注意:</strong> 此钩子函数中不应调用<code>setState( )</code>方法。如果你的组件需要使用内部<code>state</code>请直接在构造函数中为<code>this.state</code> 赋值初始<code>state</code></p><h5 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps( )"></a>static getDerivedStateFromProps( )</h5><h5 id="render"><a href="#render" class="headerlink" title="render( )"></a>render( )</h5><p>react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。<br>这里是合成虚拟DOM，可以理解为，在这里实际上都还没有真实的dom。</p><h5 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount( )"></a>componentDidMount( )</h5><p>此钩子函数会渲染真实的<code>DOM</code>浏览器，在这里才可以得到<code>DOM</code>。<br><strong>此钩子函数一般用于:</strong><br>依赖于 <code>DOM</code> 节点的初始化应该放在这里,<code>ajax</code>请求一般都在这里进行。</p><h3 id="2-渲染-amp-amp-更新"><a href="#2-渲染-amp-amp-更新" class="headerlink" title="2. 渲染&amp;&amp;更新"></a>2. 渲染&amp;&amp;更新</h3><h5 id="static-getDerivedStateFromProps-1"><a href="#static-getDerivedStateFromProps-1" class="headerlink" title="static getDerivedStateFromProps( )"></a>static getDerivedStateFromProps( )</h5><h5 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate( )"></a>shouldComponentUpdate( )</h5><h5 id="render-1"><a href="#render-1" class="headerlink" title="render( )"></a>render( )</h5><h5 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate( )"></a>getSnapshotBeforeUpdate( )</h5><h5 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate( )"></a>componentDidUpdate( )</h5><h3 id="3-卸载"><a href="#3-卸载" class="headerlink" title="3. 卸载"></a>3. 卸载</h3><h5 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount( )"></a>componentWillUnmount( )</h5><p>此钩子函数会在组件卸载及销毁之前调用。<br><strong>此钩子函数一般用于:</strong><br><strong>例 :</strong> 清除<code>timer</code>，取消网络请求或解绑某些事件<br><strong>注意:</strong> 此钩子函数中不应调用 <code>setState( )</code>因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React组件生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React组件的使用</title>
      <link href="/2020/102545355.html"/>
      <url>/2020/102545355.html</url>
      
        <content type="html"><![CDATA[<h2 id="组件的意义"><a href="#组件的意义" class="headerlink" title="组件的意义"></a>组件的意义</h2><p>React通过组件的思想，将界面拆分成一个个<code>可复用</code>的模块，每一个模块就是一个React 组件。一个React 应用由若干组件组合而成，一个复杂组件也可以由若干简单组件组合而成。</p><h2 id="创建组件方式"><a href="#创建组件方式" class="headerlink" title="创建组件方式"></a>创建组件方式</h2><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。<br><strong>定义组件的两个要求:</strong></p><ol><li>组件名称必须以大写字母开头</li><li>组件的返回值只能有一个根元素</li></ol><h3 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1. 无状态组件"></a>1. 无状态组件</h3><ol><li>就是一个函数</li><li>没有生命周期函数</li><li>不能使用state,只会接收一个props形参,并且直接使用props参数不需要this</li><li>无状态组件就是一个简单的视图函数，没有业务逻辑更纯粹的展示UI</li></ol><p><strong>代码示例:</strong></p><pre><code>function Welcome() &#123;  return (    &lt;div&gt;无状态组件&lt;/div&gt;  )&#125;</code></pre><h3 id="2-有状态组件"><a href="#2-有状态组件" class="headerlink" title="2. 有状态组件"></a>2. 有状态组件</h3><ol><li>是一个class类，继承了类的组件是有状态组件,继承自Component类</li><li>可以使用state和props,并且都是使用this来调用this.state或this.props</li><li>拥有生命周期函数</li><li>有状态组件可以使用生命周期可以在里面写业务逻辑，可以在里面做任何事情</li></ol><p><strong>代码示例:</strong></p><pre><code>class Welcome extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;      name: &quot;有状态组件&quot;    &#125;  &#125;;  componentWillMount() &#123; // 生命钩子函数，此钩子函数可以在这里做一些业务初始化操作，或者设置组件状态。    this.setState(&#123; name: &quot;你好,我是有状态组件&quot; &#125;)  &#125;  render() &#123;    return (      &lt;div&gt;&#123;this.state.name&#125;&lt;/div&gt;      // 此时页面上的展示的是 : 你好,我是有状态组件    )  &#125;&#125;</code></pre><h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p><strong>高阶组件类似高阶函数</strong>  </p><ol><li><strong>高阶函数</strong><br>高阶函数就是一个函数，但 <code>参数</code> 和 <code>返回值</code> 为 <code>函数</code> <pre><code>function hoc() &#123; return function (args) &#123;     console.log(args) &#125;&#125;hoc()(&quot;我是高级函数&quot;)</code></pre></li><li><strong>高阶组件</strong><br>高阶组件也是一个函数，但 <code>参数</code> 和 <code>返回值</code>为 <code>组件</code></li></ol><p> <strong>其实就是定义一个函数，里面返回一个有状态组件，就是高阶组件</strong><br>高阶组件就像我们吃火锅的锅底，可以在里面加羊肉、牛肉、蔬菜等。锅底相当于业务逻辑，食物相当于UI展示，可以使我们的业务逻辑层和UI层分离，代码更加清晰，更适合多人开发和维护</p><p><strong>高阶组件分为两种</strong></p><ol><li><strong>属性代理方式 :</strong><br>属性代理是最常见的高阶组件的使用方式。他通过一些操作，将包裹的组件的 <code>props</code> 和新生成的 <code>props</code>一起传递给此组件，这称之为属性代理  </li></ol><p>  <strong>特点:</strong> 返回一个全新的组件，不可以获取输入组件的state、生命周期、方法。</p><pre><code>import React from &#39;react&#39;;// 属性代理function Hoc(WithComponent, title) &#123; //WithComponent：接收传过来的组件，title：接收传来的参数  return class HocComponent extends React.Component &#123;  //return一个有状态组件  继承于React.Component    render() &#123;      return (        &lt;React.Fragment&gt;          &#123;/* name：传递的参数 */&#125;          &lt;WithComponent name=&quot;我是属性代理高阶组件&quot;&gt;&lt;/WithComponent&gt;          &lt;div&gt;&#123;title&#125;&lt;/div&gt;        &lt;/React.Fragment&gt;      )    &#125;  &#125;&#125;class App extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;    &#125;  &#125;;  render() &#123;    return (      // 使用 props 接收传递过来的参数      &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;    )  &#125;&#125;export default Hoc(App, &quot;我是属性代理高阶组件参数&quot;); //App:传递的组件</code></pre><ol start="2"><li><strong>反向继承方式 :</strong><br>反向继承返回的React组件继承了被传入的组件，它能够访问的区域、权限更多，相比属性代理方式，它更像打入组织的内部，对其进行修改  </li></ol><p>  <strong>特点:</strong> 返回输入组件的子组件，可以获取输入组件的state、生命周期、方法。</p><pre><code>import React from &#39;react&#39;;// 反向继承function Hoc(WithComponent, title) &#123; //WithComponent：接收传过来的组件，title：接收传来的参数  return class HocComponent extends WithComponent &#123;  //return一个有状态组件  继承传来过来的组件    render() &#123;      return (        &lt;React.Fragment&gt;          &lt;div&gt;&#123;title&#125;&lt;/div&gt;          &#123;/* 可以访问传递过来组件 state 中的数据 */&#125;          &#123;this.state.users&#125;          &#123;/* name：传递的参数 */&#125;          &lt;WithComponent name=&quot;我是反向继承高阶组件&quot;&gt;&lt;/WithComponent&gt;        &lt;/React.Fragment&gt;      )    &#125;  &#125;&#125;class App extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;      users: &quot;鸣人&quot;    &#125;  &#125;;  render() &#123;    return (      // 使用 props 接收传递过来的参数      &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;    )  &#125;&#125;export default Hoc(App, &quot;我是反向继承高阶组件参数&quot;); //App:传递的组件 </code></pre><h2 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h2><h3 id="1-父向子传值"><a href="#1-父向子传值" class="headerlink" title="1. 父向子传值"></a>1. 父向子传值</h3><p><strong>无状态组件直接使用props参数不需要this</strong><br><strong>有状态组件必须使用this.props</strong></p><pre><code>import React from &#39;react&#39;;import PropTypes from &#39;prop-types&#39;     //检测数据类型// 父组件class Father extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;      name: &quot;小灰灰&quot;    &#125;  &#125;;  render() &#123;    const &#123; name &#125; = this.state    return (      &lt;React.Fragment&gt;        &#123;/* title    isShow    myName父组件要传递给子组件的属性 */&#125;        &lt;Child title=&quot;父组件给子组件传值&quot; isShow=&#123;true&#125; myName=&#123;name&#125; /&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;// 子组件class Child extends React.Component &#123;  constructor() &#123;    super();    this.state = &#123;    &#125;  &#125;;  render() &#123;    const &#123; myName &#125; = this.props    return (      &lt;React.Fragment&gt;        &#123;/* 父组件向子组件传递属性，子组件使用 props 属性接收 */&#125;        &#123;this.props.title&#125;        &lt;div style=&#123;this.props.isShow ? &#123; display: &#39;block&#39; &#125; : &#123; display: &#39;none&#39; &#125;&#125;&gt;我是一个盒子&lt;/div&gt;        &lt;h4&gt;我的名字: &#123;myName&#125;&lt;/h4&gt;      &lt;/React.Fragment&gt;    )  &#125;&#125;//检测属性值的类型Child.propTypes = &#123;  title: PropTypes.string.isRequired,  //isRequired：检查是否为必填项  isShow: PropTypes.bool,  myName: PropTypes.string,  // &#125;//默认传递属性值Child.defaultProps = &#123;  title: &quot;默认传递&quot;  //如果父组件没有传递title属性，默认传递此属性值&#125;export default Father;</code></pre><h3 id="2-子向父传值"><a href="#2-子向父传值" class="headerlink" title="2. 子向父传值"></a>2. 子向父传值</h3><p><strong>如果子组件对父组件进行传值，则需要通过事件触发，子组件调用在父组件中的方法，并以传递参数的形式来将子组件中的state传递给父组件</strong><br><strong>父组件:</strong></p><pre><code>import React from &#39;react&#39;import Son from &#39;./son&#39;;class App extends React.Component&#123;    constructor() &#123;        super();        this.state=&#123;        msg:&quot;&quot;        &#125;    &#125;    getChildren(val) &#123;        this.setState(&#123;msg:val&#125;)    &#125;    render() &#123;        return(            &lt;div&gt;                &lt;Son sendParent=&#123;this.getChildren.bind(this)&#125; /&gt;                &#123;this.state.msg&#125;            &lt;/div&gt;        )    &#125;&#125;export default App;</code></pre><p><strong>子组件:</strong></p><pre><code>import React from &#39;react&#39;;class Son extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            msg: &quot;我是子组件的值&quot;        &#125;    &#125;    render() &#123;        return (            &lt;div&gt;              &lt;button type=&quot;button&quot; onClick=&#123;this.props.sendParent.bind(this,this.state.msg)&#125;&gt;请点击我&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default Son</code></pre><h2 id="组件之间传递方法"><a href="#组件之间传递方法" class="headerlink" title="组件之间传递方法"></a>组件之间传递方法</h2><h3 id="父向子传递方法"><a href="#父向子传递方法" class="headerlink" title="父向子传递方法"></a>父向子传递方法</h3><p><strong>父组件:</strong></p><pre><code>import React from &#39;react&#39;;import Son from &quot;./son&quot;class Father extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            msg: &quot;我是父组件中的方法&quot;        &#125;    &#125;    parent() &#123;        alert(this.state.msg)    &#125;    render() &#123;        return(            &lt;div&gt;                &lt;Son parentMethod=&#123;this.parent.bind(this)&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;export default Father</code></pre><p><strong>子组件:</strong></p><pre><code>import React from &#39;react&#39;;class Son extends React.Component &#123;    constructor() &#123;        super();        this.state=&#123;&#125;    &#125;    render() &#123;        return(            &lt;div&gt;                &lt;button onClick=&#123;this.props.parentMethod.bind(this)&#125;&gt;点我&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;export default Son;</code></pre><h3 id="子向父传递方法"><a href="#子向父传递方法" class="headerlink" title="子向父传递方法"></a>子向父传递方法</h3><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="1-登录案例"><a href="#1-登录案例" class="headerlink" title="1. 登录案例"></a>1. 登录案例</h3><pre><code>import React from &quot;react&quot;import Hoc from &quot;./proxy&quot;const Login = Hoc((props) =&gt; &#123;     //将此无状态组件传递到./proxy    console.log(&#123; ...props.username &#125;)    return (        &lt;React.Fragment&gt;            &#123;/* 传递过来的参数 */&#125;            &lt;div&gt;&#123;props.title&#125; &#123;props.id&#125;&lt;/div&gt;            用index户名: &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; &#123;...props.username&#125; /&gt; &#123;props.username.value&#125;            &#123;props.nulls.isNullusername ? &quot;请输入用户名&quot; : &quot;&quot;&#125;            &lt;br /&gt;            密码: &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; &#123;...props.password&#125; /&gt; &#123;props.password.value&#125;            &#123;props.nulls.isNullpassword ? &quot;请输入用密码&quot; : &quot;&quot;&#125;            &lt;br /&gt;            &lt;button type=&quot;button&quot; onClick=&#123;props.submit.bind(this, () =&gt; &#123;                alert(&#39;提交数据&#39;)            &#125;)&#125;&gt;登录&lt;/button&gt;        &lt;/React.Fragment&gt;    )&#125;)class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;        &#125;    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;Login title=&quot;会员登录&quot; id=&quot;1&quot;&gt;&lt;/Login&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><pre><code>//proxy文件// 属性代理import React from &quot;react&quot;export default function Hoc(WithComponent) &#123;              //接收组件    return class HocComponent extends React.Component &#123;   //继承于React.Component        constructor() &#123;            super();            this.state = &#123;                username: &quot;&quot;,                password: &quot;&quot;,                isNullusername: false,                isNullpassword: false            &#125;        &#125;        setUsername(e) &#123;            this.setState(&#123; username: e.target.value &#125;)        &#125;        setPassword(e) &#123;            this.setState(&#123; password: e.target.value &#125;)        &#125;        submitData(callback) &#123;     //提交数据            if(this.state.username.match(/`\s*$/))&#123;                this.setState(&#123;isNullusername:true&#125;)                return;            &#125;            if(this.state.username.match(/`\s*$/))&#123;                this.setState(&#123;isNullpassword:true&#125;)                return;            &#125;            if(typeof callback===&#39;function&#39;) &#123;                callback();            &#125;        &#125;        render() &#123;            let newProps = &#123;                username: &#123; // 用户名                    onChange: this.setUsername.bind(this),                    value: this.state.username                &#125;,                password: &#123; //用户密码                    onChange: this.setPassword.bind(this),                    value: this.state.password                &#125;,                nulls:&#123;  //  显示条件                    isNullusername: this.state.isNullusername,                    isNullpassword: this.state.isNullpassword,                &#125;            &#125;                        return (                &lt;React.Fragment&gt;                    &#123;/* &lt;WithComponent title=&#123;this.props.title&#125; &#123;...this.props&#125; setUsername=&#123;this.setUsername.bind(this)&#125; username=&#123;this.state.username&#125;&gt;&lt;/WithComponent&gt; */&#125;                    &#123;/*WithComponent 传递过来得组件。  传入的参数过多时，采用扩展运算符无限获取参数 */&#125;                    &lt;WithComponent  &#123;...this.props&#125; &#123;...newProps&#125; submit=&#123;this.submitData.bind(this)&#125;&gt;&lt;/WithComponent&gt;                &lt;/React.Fragment&gt;            )        &#125;    &#125;&#125;</code></pre><h3 id="2-轮播图案例"><a href="#2-轮播图案例" class="headerlink" title="2. 轮播图案例"></a>2. 轮播图案例</h3><p><strong>父组件 :</strong></p><pre><code>//轮播图数据源import React from &#39;react&#39;import Swiper from &#39;../../components/swiper&#39;class App extends React.Component &#123;    constructor() &#123;        super();        this.state = &#123;            images: [                &#123; src: require(&quot;../../assets/images/banner1.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,                &#123; src: require(&quot;../../assets/images/banner2.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,            ]        &#125;    &#125;    render() &#123;        return (            &lt;React.Fragment&gt;                &lt;Swiper data=&#123;this.state.images&#125; /&gt;            &lt;/React.Fragment&gt;        )    &#125;&#125;export default App;</code></pre><pre><code>//轮播图逻辑import React from &#39;react&#39;;import Proptypes from &#39;prop-types&#39;;export default function Hoc(WithCompont) &#123;    return class HocCompont extends React.Component &#123;        static propTypes = &#123;  //检测传递过来的数据类型            data: Proptypes.array.isRequired   //isRequired为必填项        &#125;        static defaultProps = &#123; //默认值            data: []        &#125;        constructor(props) &#123;            super(props);            this.state = &#123;                data: []            &#125;            this.aData = []            this.isInit = true            this.timer = null            this.index = 0        &#125;        change(index) &#123;   //点击切换图片            this.isInit = false            this.index = index            if (this.aData.length &gt; 0) &#123;                for (let i = 0; i &lt; this.aData.length; i++) &#123;                    if (this.aData[i].active) &#123;                        this.aData[i].active = false;                        break;                    &#125;                &#125;            &#125;            this.aData[index].active = true;            this.setState(&#123; data: this.aData &#125;)        &#125;        autoPlay() &#123;//自动播放            this.timer = setInterval(() =&gt; &#123;                if (this.aData.length &gt; 0) &#123;                    this.isInit = false;                    for (let i = 0; i &lt; this.aData.length; i++) &#123;                        if (this.aData[i].active) &#123;                            this.aData[i].active = false;                            break;                        &#125;                    &#125;                    if (this.index &gt;= this.aData.length - 1) &#123;                        this.index = 0;                    &#125; else &#123;                        this.index++                        console.log(this.index)                    &#125;                    this.aData[this.index].active = true;                    this.setState(&#123; data: this.aData &#125;)                &#125;            &#125;, (3000))        &#125;        stop() &#123; //鼠标经过清除定时器            clearInterval(this.timer)        &#125;        componentDidMount() &#123;            this.setState(&#123; data: this.props.data &#125;)            this.autoPlay();  //开启定时器        &#125;        componentWillUnmount() &#123;            clearInterval(this.timer)  //清除定时器        &#125;        render() &#123;            console.log(this.props)   //父组件传递过来的参数            this.aData = this.props.data;            if (this.aData &amp;&amp; this.aData.length &gt; 0 &amp;&amp; this.isInit) &#123;                for (let i = 0; i &lt; this.aData.length; i++) &#123;                    if (i == 0) &#123;                        this.aData[i].active = true;                    &#125; else &#123;                        this.aData[i].active = false                    &#125;                &#125;            &#125;            return (                //传递参数以及方法                &lt;WithCompont &#123;...this.props&#125; change=&#123;this.change.bind(this)&#125; stop=&#123;this.stop.bind(this)&#125; autoPlay=&#123;this.autoPlay.bind(this)&#125;&gt;&lt;/WithCompont&gt;            )        &#125;    &#125;&#125;</code></pre><pre><code>//轮播图视图层import React from &#39;react&#39;import Hoc from &#39;./hoc&#39;import &quot;./style.css&quot;// export default function hoc()&#123;export default Hoc((props) =&gt; &#123;    console.log(props)    let aData = props.data;    return (        &lt;div className=&quot;banner&quot;&gt;            &lt;div className=&quot;my-swiper-main&quot; onMouseOver=&#123;props.stop.bind(this)&#125; onMouseOut=&#123;props.autoPlay.bind(this)&#125;&gt;                &#123;                    aData.length &gt; 0 &amp;&amp; aData.map((item, index) =&gt; &#123;                        return (                            &lt;div className=&#123;item.active ? &quot;my-slide show&quot; : &quot;my-slide&quot;&#125; key=&#123;index&#125;&gt;                                &lt;a href=&#123;item.url&#125; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;                                    &lt;img src=&#123;item.src&#125; alt=&quot;&quot; /&gt;                                &lt;/a&gt;                            &lt;/div&gt;                        )                    &#125;)                &#125;                &lt;div className=&quot;pagination&quot;&gt;                    &#123;                        aData.length &gt; 0 &amp;&amp; aData.map((item, index) =&gt; &#123;                            return (                                &lt;div className=&#123;item.active ? &quot;dot active&quot; : &quot;dot&quot;&#125; key=&#123;index&#125; onClick=&#123;props.change.bind(this, index)&#125;&gt;&lt;/div&gt;                            )                        &#125;)                    &#125;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    )&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React创建组件 </tag>
            
            <tag> React组件传值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2020/101852877.html"/>
      <url>/2020/101852877.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>Markdown具有一系列衍生版本，用于扩展Markdown的功能，这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown 语言在 2004 由约翰·格鲁伯（John Gruber）创建。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客等。<br>当前许多网站都使用了Markdown来撰写帮助文档或是用于论坛上发表消息。例如简书、知乎、CSDN、GitHub、OpenStreetMap 、Diaspora等。  </p><h2 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，两个#是二级标题，以此类推。支持六级标题，标题字号逐级递减降低<br><strong>注意：语法在#后跟个空格再写文字</strong><br><strong>示列:</strong></p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><p><strong>效果如下:</strong>  </p><div align=center><img src="https://img-blog.csdnimg.cn/20200426182643977.png?" width = 50% height = 50%></div><h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h3><p>斜体<br>要倾斜的文字左右分别用一个 * 号包起来<br>加粗<br>要加粗的文字左右分别用两个 * 号包起来<br>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来<br>删除线<br>要加删除线的文字左右分别用两个~~号包起来<br><strong>示列:</strong></p><pre><code>*这是倾斜的文字***这是加粗的文字*****这是斜体加粗的文字***~~这是加删除线的文字~~</code></pre><p><strong>效果如下:</strong><br><em>这是倾斜的文字</em><br><strong>这是加粗的文字</strong><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del>  </p><h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a>3. 分割线</h3><p>三个 - 或者 *<br><strong>示列:</strong></p><pre><code>---***</code></pre><p><strong>效果如下:</strong></p><hr><hr><h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h3><p>在需要引用的文字前加 &gt;<br><strong>示列:</strong></p><pre><code>&gt;大家好，你们好</code></pre><p><strong>效果如下:</strong></p><blockquote><p>大家好，你们好</p></blockquote><h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h3><p>![图片下方显示名字](“图片url 鼠标放在图片上的显示信息”)<br><strong>示列:</strong></p><pre><code>![我是皮卡丘](https://img-blog.csdnimg.cn/20200507103002365.png &quot;皮卡皮卡&quot;)</code></pre><p><strong>效果如下:</strong></p><div align=center><p><img src="https://img-blog.csdnimg.cn/20200507103002365.png" alt="我是皮卡丘" title="皮卡皮卡"></p></div><h3 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h3><pre><code>[网址名](网址) </code></pre><p><strong>示列:</strong></p><pre><code>[GitHub](https://github.com/)[百度](https://www.baidu.com/) </code></pre><p><a href="https://github.com/">GitHub</a><br><a href="https://www.baidu.com/">百度</a> </p><h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h3><p><strong>有序列表:</strong><br>数字加上 . (后面跟上一个空格)<br><strong>示列:</strong></p><pre><code>1. 有序列表2. 有序列表3. 有序列表</code></pre><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><p><strong>无序列表:</strong><br>内容前面加上 *，+，- (后面跟上一个空格)<br><strong>示列:</strong></p><pre><code>* 无序列表+ 无序列表- 无序列表</code></pre><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><ul><li>无序列表</li></ul><h3 id="8-代码插入"><a href="#8-代码插入" class="headerlink" title="8. 代码插入"></a>8. 代码插入</h3><p>单行代码:<br>用两个`把代码内容包起来<br>‘包裹的代码’<br><strong>示列:</strong></p><p><code>Hello World</code></p><p>代码块:<br>用 两个```把代码块包起来<br><strong>示列:</strong></p><pre><code>var num =(function(a, b ,c)&#123;    var d = a + b + c + 1;      return d&#125;(1,2,3))</code></pre><h2 id="Markdown进阶"><a href="#Markdown进阶" class="headerlink" title="Markdown进阶"></a>Markdown进阶</h2><h3 id="1-文字缩进"><a href="#1-文字缩进" class="headerlink" title="1. 文字缩进"></a>1. 文字缩进</h3><p>在要缩进的文字前使用 <code>&amp;emsp;</code>(注意后面要加上空格)<br><strong>示列:</strong><br>我是缩进前的文字<br>&emsp; &emsp; &emsp; 我是缩进后的文字</p><h3 id="2-文字居中"><a href="#2-文字居中" class="headerlink" title="2. 文字居中"></a>2. 文字居中</h3><p>对于标准的markdown文本，是不支持居中对齐的。但是markdown支持html语言，所以可以采用html语法格式来实现<br><strong>示列:</strong></p><pre><code>&lt;center&gt;我要居中显示&lt;/center&gt;</code></pre><center>我要居中显示</center><h3 id="3-字体字号及颜色"><a href="#3-字体字号及颜色" class="headerlink" title="3. 字体字号及颜色"></a>3. 字体字号及颜色</h3><p>同样采用HTML语法实现<br><strong>示列:</strong></p><pre><code>&lt;center&gt;&lt;font face=&quot;微软雅黑&quot; size=8 color=red&gt;我是一行文本&lt;/font&gt;&lt;/center&gt;</code></pre><center><font face="微软雅黑" size=8 color=red>我是一行文本</font></center><h3 id="4-图片的大小和位置"><a href="#4-图片的大小和位置" class="headerlink" title="4. 图片的大小和位置"></a>4. 图片的大小和位置</h3><p>center 居中 ，center换成 left 和 right 可以实现居左，居右<br>width 和 height 调控宽度和高度<br><strong>示列:</strong></p><pre><code>&lt;div  align=&quot;center&quot;&gt;    &lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3222272914,986927614&amp;fm=26&amp;gp=0.jpg&quot; width = 50% height = 50% /&gt;&lt;/div&gt;  </code></pre><div  align="center">    <img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3222272914,986927614&fm=26&gp=0.jpg" width = 50% height = 50% /></div>  <h2 id="Markdown更多用法"><a href="#Markdown更多用法" class="headerlink" title="Markdown更多用法"></a>Markdown更多用法</h2><p><a href="https://markdown-zh.readthedocs.io/">Markdown 中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
