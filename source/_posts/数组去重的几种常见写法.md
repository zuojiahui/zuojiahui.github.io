---
title: 数组去重的几种常见写法
categories: JavaScript
tags:
  - 数组去重
abbrlink: 28872
---
### 前言
在实际工作或面试中，我们经常会遇到“数组去重”问题，以下来是总结的一些实现的数组去重的多种方法
### 方法一
使用双层循环改变原数组
```
var arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 1, 2, 6, 6, 6, 6];
function norepeat(arr) {
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0; j < arr.length; j++) {
      if (arr[i] == arr[j] && i != j) {
        arr.splice(j, 1);
      }
    }
  }
  return arr;
}
var arr2 = norepeat(arr);
console.log(arr2);      //[1, 2, 3, 4, 5, 6]
console.log(arr)        //[1, 2, 3, 4, 5, 6]
```
### 方法二
使用 es6 中Set方法，此方法最为简便
```
let arr = [1, 4, 3, 6, 3, 4, 5, 7, 6, 2];
//写法一
let set = new Set(arr);
let arr1 = Array.from(set); // Array.from方法可以将 Set 结构转为数组。
// 写法二
let arr2 = [...new Set(arr)]
console.log(arr1);      //[ 1, 2, 4, 3, 6 ]
console.log(arr2);      //[1, 4, 3, 6, 5, 7, 2]
console.log(arr);       //[1, 4, 3, 6, 3, 4, 5, 7, 6, 2]
```
### 方法三
将数组的每一个元素依次与其他元素做比较，发现重复元素，利用数组方法splice()删除重复元素
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5, 5];
function norepeat(arr) {
  for (var i = 0; i < arr.length - 1; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[i] == arr[j]) {
        arr.splice(j, 1);
        j--;
      }
    }
  }
  return arr;
}
var arr2 = norepeat(arr);
console.log(arr2);         //[1, 23, 3, 5, 6, 7, 9, 8]
console.log(arr);          //[1, 23, 3, 5, 6, 7, 9, 8]
```
### 方法四
借助新数组，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中（原数组长度不变但被按字符串顺序排序）
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];
function norepeat(arr) {
  var temp = [];
  var end; //临时变量用于对比重复元素
  arr.sort();
  end = arr[0];
  temp.push(arr[0]);
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] != end) {
      //当前元素如果和临时元素不等则将此元素添加到新数组中
      temp.push(arr[i]);
      end = arr[i];
    }
  }
  return temp;
}
var arr2 = norepeat(arr);
console.log(arr2);       //[1, 23, 3, 5, 6, 7, 8, 9]
console.log(arr);        //[1, 1, 1, 1, 23, 23, 3, 5, 5, 6, 7, 8, 9, 9]
```
### 方法五
创建一个新数组，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];
function norepeat(arr) {
  var temp = [];
  for (var i = 0; i < arr.length; i++) {
    if (temp.indexOf(arr[i]) == -1) {
      temp.push(arr[i]);
    }
  }
  return temp;
}
var arr2 = norepeat(arr);
console.log(arr2);      //[1, 23, 3, 5, 6, 7, 9, 8]
console.log(arr);       //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5]
```
### 方法六
借助indexOf()方法判断此元素在该数组中首次出现的位置下标与循环的下标是否相等
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];
function norepeat(arr) {
  for (var i = 0; i < arr.length; i++) {
    if (arr.indexOf(arr[i]) != i) {
      arr.splice(i, 1); //删除数组元素后数组长度减1后面的元素前移
      i--; //数组下标回退
    }
  }
  return arr;
}
var arr2 = norepeat(arr);
console.log(arr2);      //[1, 23, 3, 5, 6, 7, 9, 8]
console.log(arr);       //[1, 23, 3, 5, 6, 7, 9, 8]
```
### 方法七
创建一个新数组 通过indexOf方判断当前元素在数组中的索引如果与循环的下标相等则添加到新数组中
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];
function norepeat(arr) {
  var temp = [];
  for (var i = 0; i < arr.length; i++) {
    if (arr.indexOf(arr[i]) == i) {
      temp.push(arr[i]);
    }
  }
  return temp;
}
var arr2 = norepeat(arr);
console.log(arr2);     //[1, 23, 3, 5, 6, 7, 9, 8]
console.log(arr);      //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5]
```
### 方法八
利用数组中的filter方法
```
var arr = [1, 4, 2, 2, 3, 1, 3, 4, 5, 6, 6, 8, 9];
var arr2 = arr.filter(function (value, index, self) {
  return self.indexOf(value) === index;
});
console.log(arr2);    //[1, 4, 2, 3, 5, 6, 8, 9]
console.log(arr);     //[1, 4, 2, 2, 3, 1, 3, 4, 5, 6, 6, 8, 9]
```
### 方法九
利用空对象来记录新数组中已经存储过的元素
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];
var obj = {};
var arr2 = [];
for (var i = 0; i < arr.length; i++) {
  if (!obj[arr[i]]) {
    obj[arr[i]] = true;
    arr2.push(arr[i]);
  }
}
console.log(arr2);    //[1, 23, 3, 5, 6, 7, 9, 8]
console.log(arr);     //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5]
```
### 方法十
借助两个新数组
```
var arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 2, 1, 1, 1];
var arr2 = [];
for (var i = 0; i < arr.length; i++) {
  var arr3 = []; //接收重复数据后面的下标
  //内层循环找出有重复数据的下标
  for (var j = i + 1; j < arr.length; j++) {
    if (arr[i] == arr[j]) {
      arr3.push(j); //找出后面重复数据的下标
    }
  }
  // console.log(arr3);
  if (arr3.length == 0) {
    //若重复数组没有值说明其不是重复数据
    arr2.push(arr[i]);
  }
}
console.log(arr2);     //[5, 4, 3, 2, 1]
console.log(arr);      //[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 2, 1, 1, 1]
```
### 方法十一
此方法没有借助新数组直接改变原数组,并且去重后的数组被排序
```
var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];
function norepeat(arr) {
  var temp;
  arr.sort();
  temp = arr[0];
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] == temp) {
      //当前元素如果和临时元素相等则将此元素从数组中删除
      arr.splice(i, 1);
      i--;
    } else {
      temp = arr[i];
    }
  }
  return arr;
}
var arr2 = norepeat(arr);
console.log(arr2);     //[1, 23, 3, 5, 6, 7, 8, 9]
console.log(arr);      //[1, 23, 3, 5, 6, 7, 8, 9]
```